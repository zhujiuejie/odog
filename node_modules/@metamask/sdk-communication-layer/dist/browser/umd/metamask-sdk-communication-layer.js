!function(global,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("tslib"),require("cross-fetch"),require("debug"),require("buffer"),require("eciesjs"),require("@metamask/sdk-analytics"),require("eventemitter2"),require("uuid"),require("socket.io-client")):"function"==typeof define&&define.amd?define(["exports","tslib","cross-fetch","debug","buffer","eciesjs","@metamask/sdk-analytics","eventemitter2","uuid","socket.io-client"],e):e((global="undefined"!=typeof globalThis?globalThis:global||self).MetaMaskSDKCommunication={},global.tslib,global.fetch,global.debug,global.Buffer,global.ECIES,global.sdkAnalytics,global.EventEmitter2,global.uuid,global.io)}(this,(function(e,t,n,i,o,a,s,c,r,l){"use strict";function d(e){return e&&e.__esModule?e:{default:e}}var u=d(n),h=d(i);const y=h.default("KeyExchange:Layer"),E=h.default("SocketService:Layer"),m=h.default("Ecies:Layer"),v=h.default("RemoteCommunication:Layer");y.color="##95c44e",E.color="#f638d7",m.color="#465b9c",v.color="#47a2be";const g={KeyExchange:y,SocketService:E,Ecies:m,RemoteCommunication:v};let p,S=[],C=[];const _=(e,n)=>t.__awaiter(void 0,void 0,void 0,(function*(){p=n,C.push(e),function(e){return t.__awaiter(this,void 0,void 0,(function*(){if(!p||!e)return;!function(){const e=C;C=S,S=e}();const t=p.endsWith("/")?`${p}evt`:`${p}/evt`,n=Object.assign({},e);if(delete n.params,e.params)for(const[t,i]of Object.entries(e.params))n[t]=i;const i=JSON.stringify(n);g.RemoteCommunication(`[sendBufferedEvents] Sending ${S.length} analytics events to ${t}`);try{const e=yield u.default(t,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:i}),n=yield e.text();g.RemoteCommunication(`[sendBufferedEvents] Response: ${n}`),S.length=0}catch(e){}}))}(e).catch((()=>{}))}));class T{constructor(e){this.enabled=!0,(null==e?void 0:e.debug)&&h.default.enable("Ecies:Layer"),this.ecies=(null==e?void 0:e.privateKey)?a.PrivateKey.fromHex(e.privateKey):new a.PrivateKey,g.Ecies("[ECIES constructor()] initialized secret: ",this.ecies.toHex()),g.Ecies("[ECIES constructor()] initialized public: ",this.ecies.publicKey.toHex()),g.Ecies("[ECIES constructor()] init with",this)}generateECIES(){this.ecies=new a.PrivateKey}getPublicKey(){return this.ecies.publicKey.toHex()}encrypt(e,t){let n=e;if(this.enabled)try{g.Ecies("[ECIES: encrypt()] using otherPublicKey",t);const i=o.Buffer.from(e),s=a.encrypt(t,i);n=o.Buffer.from(s).toString("base64")}catch(n){throw g.Ecies("[ECIES: encrypt()] error encrypt:",n),g.Ecies("[ECIES: encrypt()] private: ",this.ecies.toHex()),g.Ecies("[ECIES: encrypt()] data: ",e),g.Ecies("[ECIES: encrypt()] otherkey: ",t),n}return n}decrypt(e){let t=e;if(this.enabled)try{g.Ecies("[ECIES: decrypt()] using privateKey",this.ecies.toHex());const n=o.Buffer.from(e.toString(),"base64");t=a.decrypt(this.ecies.toHex(),n).toString()}catch(t){throw g.Ecies("[ECIES: decrypt()] error decrypt",t),g.Ecies("[ECIES: decrypt()] private: ",this.ecies.toHex()),g.Ecies("[ECIES: decrypt()] encryptedData: ",e),t}return t}getKeyInfo(){return{private:this.ecies.toHex(),public:this.ecies.publicKey.toHex()}}toString(){g.Ecies("[ECIES: toString()]",this.getKeyInfo())}}var f={name:"@metamask/sdk-communication-layer",version:"0.33.1",description:"",homepage:"https://github.com/MetaMask/metamask-sdk#readme",bugs:{url:"https://github.com/MetaMask/metamask-sdk/issues"},repository:{type:"git",url:"https://github.com/MetaMask/metamask-sdk.git",directory:"packages/sdk-communication-layer"},main:"dist/node/cjs/metamask-sdk-communication-layer.js",unpkg:"dist/browser/umd/metamask-sdk-communication-layer.js",module:"dist/node/es/metamask-sdk-communication-layer.js",browser:"dist/browser/es/metamask-sdk-communication-layer.js","react-native":"dist/react-native/es/metamask-sdk-communication-layer.js",types:"dist/types/src/index.d.ts",files:["/dist"],scripts:{"build:types":"tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types","build:clean":"yarn clean && yarn build",build:"yarn build:types && rollup -c --bundleConfigAsCjs","build:dev":"yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs",dev:'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"',"build:post-tsc":"echo 'N/A'","build:pre-tsc":"echo 'N/A'",size:"size-limit",clean:"rimraf ./dist",lint:"yarn lint:eslint && yarn lint:misc --check","lint:changelog":"../../scripts/validate-changelog.sh @metamask/sdk-communication-layer","lint:eslint":"eslint . --cache --ext js,ts","lint:fix":"yarn lint:eslint --fix && yarn lint:misc --write","lint:misc":"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore","publish:preview":"yarn npm publish --tag preview",prepack:"../../scripts/prepack.sh",reset:"yarn clean && rimraf ./node_modules/",test:'jest --testPathIgnorePatterns "/e2e/"',"test:e2e":'jest --testPathPattern "/e2e/"',"test:coverage":"jest --coverage","test:ci":'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"',"test:dev":"jest",watch:"rollup -c --bundleConfigAsCjs -w"},dependencies:{"@metamask/sdk-analytics":"workspace:*",bufferutil:"^4.0.8","date-fns":"^2.29.3",debug:"4.3.4","utf-8-validate":"^5.0.2",uuid:"^8.3.2"},devDependencies:{"@jest/globals":"^29.3.1","@lavamoat/allow-scripts":"^2.3.1","@metamask/auto-changelog":"3.1.0","@metamask/eslint-config":"^6.0.0","@metamask/eslint-config-nodejs":"^6.0.0","@metamask/eslint-config-typescript":"^6.0.0","@rollup/plugin-commonjs":"^25.0.0","@rollup/plugin-json":"^6.0.0","@rollup/plugin-node-resolve":"^15.0.2","@rollup/plugin-replace":"^6.0.1","@rollup/plugin-terser":"^0.4.4","@size-limit/preset-big-lib":"^11.0.2","@types/jest":"^29.2.4","@types/node":"^20.1.3","@types/uuid":"^9.0.0","@typescript-eslint/eslint-plugin":"^4.26.0","@typescript-eslint/parser":"^4.26.0",concurrently:"^9.1.2","cross-fetch":"^4.0.0",eciesjs:"^0.4.11",eslint:"^7.30.0","eslint-config-prettier":"^8.3.0","eslint-plugin-import":"^2.23.4","eslint-plugin-jest":"^24.4.0","eslint-plugin-jsdoc":"^36.1.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^3.4.0",eventemitter2:"^6.4.9",jest:"^29.3.1",prettier:"^2.3.0",rimraf:"^3.0.2",rollup:"^4.26.0","rollup-plugin-jscc":"^2.0.0","rollup-plugin-natives":"^0.7.5","rollup-plugin-node-builtins":"^2.1.2","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-peer-deps-external":"^2.2.4","rollup-plugin-polyfill-node":"^0.13.0","rollup-plugin-sizes":"^1.0.6","rollup-plugin-typescript2":"^0.31.2","rollup-plugin-visualizer":"^5.12.0","size-limit":"^11.1.6","socket.io-client":"^4.5.1","stream-browserify":"^3.0.0","ts-jest":"^29.0.3","ts-node":"^10.9.1",typescript:"^5.6.3"},peerDependencies:{"cross-fetch":"^4.0.0",eciesjs:"*",eventemitter2:"^6.4.9","readable-stream":"^3.6.2","socket.io-client":"^4.5.1"},publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},lavamoat:{allowScripts:{"@lavamoat/preinstall-always-fail":!1,canvas:!0,"eciesjs>secp256k1":!1,"socket.io-client>engine.io-client>ws>bufferutil":!1,"socket.io-client>engine.io-client>ws>utf-8-validate":!1,bufferutil:!1,"utf-8-validate":!1}}};const k="https://metamask-sdk.api.cx.metamask.io/",K=["websocket"],I=6048e5,x=3e3,A={METAMASK_GETPROVIDERSTATE:"metamask_getProviderState",METAMASK_CONNECTSIGN:"metamask_connectSign",METAMASK_CONNECTWITH:"metamask_connectWith",METAMASK_OPEN:"metamask_open",METAMASK_BATCH:"metamask_batch",PERSONAL_SIGN:"personal_sign",WALLET_REQUESTPERMISSIONS:"wallet_requestPermissions",WALLET_REVOKEPERMISSIONS:"wallet_revokePermissions",WALLET_GETPERMISSIONS:"wallet_getPermissions",WALLET_WATCHASSET:"wallet_watchAsset",WALLET_SWITCHETHEREUMCHAIN:"wallet_switchEthereumChain",WALLET_ADDETHEREUMCHAIN:"wallet_addEthereumChain",ETH_REQUESTACCOUNTS:"eth_requestAccounts",ETH_ACCOUNTS:"eth_accounts",ETH_CHAINID:"eth_chainId",ETH_SENDTRANSACTION:"eth_sendTransaction",ETH_SIGNTYPEDDATA:"eth_signTypedData",ETH_SIGNTYPEDDATA_V3:"eth_signTypedData_v3",ETH_SIGNTYPEDDATA_V4:"eth_signTypedData_v4",ETH_SIGNTRANSACTION:"eth_signTransaction",ETH_SIGN:"eth_sign",PERSONAL_EC_RECOVER:"personal_ecRecover"},N=[A.METAMASK_CONNECTSIGN,A.METAMASK_CONNECTWITH,A.METAMASK_OPEN,A.METAMASK_BATCH,A.PERSONAL_SIGN,A.WALLET_REQUESTPERMISSIONS,A.WALLET_REVOKEPERMISSIONS,A.WALLET_WATCHASSET,A.ETH_SENDTRANSACTION,A.ETH_SIGNTYPEDDATA,A.ETH_SIGNTYPEDDATA_V3,A.ETH_SIGNTYPEDDATA_V4,A.ETH_SIGNTRANSACTION,A.ETH_SIGN,A.PERSONAL_EC_RECOVER];function O(e){return N.includes(e)}function R(e){const{context:t}=e;g.RemoteCommunication(`[RemoteCommunication: clean()] context=${t}`),e.channelConfig=void 0,e.ready=!1,e.originatorConnectStarted=!1}var w,P,D,M,b,L;e.ConnectionStatus=void 0,(w=e.ConnectionStatus||(e.ConnectionStatus={})).DISCONNECTED="disconnected",w.WAITING="waiting",w.TIMEOUT="timeout",w.LINKED="linked",w.PAUSED="paused",w.TERMINATED="terminated",e.EventType=void 0,(P=e.EventType||(e.EventType={})).KEY_INFO="key_info",P.SERVICE_STATUS="service_status",P.PROVIDER_UPDATE="provider_update",P.RPC_UPDATE="rpc_update",P.KEYS_EXCHANGED="keys_exchanged",P.JOIN_CHANNEL="join_channel",P.PUBLIC_KEY="public_key",P.CHANNEL_CREATED="channel_created",P.CLIENTS_CONNECTED="clients_connected",P.CLIENTS_DISCONNECTED="clients_disconnected",P.CLIENTS_WAITING="clients_waiting",P.CLIENTS_READY="clients_ready",P.REJECTED="rejected",P.WALLET_INIT="wallet_init",P.CHANNEL_PERSISTENCE="channel_persistence",P.CONFIG="config",P.MESSAGE_ACK="ack",P.SOCKET_DISCONNECTED="socket_disconnected",P.SOCKET_RECONNECT="socket_reconnect",P.OTP="otp",P.SDK_RPC_CALL="sdk_rpc_call",P.AUTHORIZED="authorized",P.CONNECTION_STATUS="connection_status",P.MESSAGE="message",P.TERMINATE="terminate",function(e){e.KEY_EXCHANGE="key_exchange"}(D||(D={})),e.KeyExchangeMessageType=void 0,(M=e.KeyExchangeMessageType||(e.KeyExchangeMessageType={})).KEY_HANDSHAKE_START="key_handshake_start",M.KEY_HANDSHAKE_CHECK="key_handshake_check",M.KEY_HANDSHAKE_SYN="key_handshake_SYN",M.KEY_HANDSHAKE_SYNACK="key_handshake_SYNACK",M.KEY_HANDSHAKE_ACK="key_handshake_ACK",M.KEY_HANDSHAKE_WALLET="key_handshake_wallet",M.KEY_HANDSHAKE_NONE="none";class $ extends c.EventEmitter2{constructor({communicationLayer:t,otherPublicKey:n,context:i,ecies:o,logging:a}){super(),this.keysExchanged=!1,this.step=e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE,this.debug=!1,this.context=i,this.communicationLayer=t,(null==o?void 0:o.privateKey)&&n&&(g.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${n} set keysExchanged to true!`,o),this.keysExchanged=!0),this.myECIES=new T(Object.assign(Object.assign({},o),{debug:null==a?void 0:a.eciesLayer})),this.communicationLayer.state.eciesInstance=this.myECIES,this.myPublicKey=this.myECIES.getPublicKey(),this.debug=!0===(null==a?void 0:a.keyExchangeLayer),n&&this.setOtherPublicKey(n),this.communicationLayer.on(D.KEY_EXCHANGE,this.onKeyExchangeMessage.bind(this))}onKeyExchangeMessage(t){const{relayPersistence:n}=this.communicationLayer.remote.state;if(g.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${n}`,t),n)return void g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");const{message:i}=t;this.keysExchanged&&g.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`),this.emit(e.EventType.KEY_INFO,i.type),i.type===e.KeyExchangeMessageType.KEY_HANDSHAKE_SYN?(this.checkStep([e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE,e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK]),g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN",i),i.pubkey&&this.setOtherPublicKey(i.pubkey),this.communicationLayer.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey}).catch((e=>{g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK",e)})),this.setStep(e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK)):i.type===e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK?(this.checkStep([e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK,e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE]),g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"),i.pubkey&&this.setOtherPublicKey(i.pubkey),this.communicationLayer.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}).catch((e=>{g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK",e)})),this.keysExchanged=!0,this.setStep(e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK),this.emit(e.EventType.KEYS_EXCHANGED)):i.type===e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK&&(g.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"),this.checkStep([e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK,e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE]),this.keysExchanged=!0,this.setStep(e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK),this.emit(e.EventType.KEYS_EXCHANGED))}resetKeys(e){this.clean(),this.myECIES=new T(e)}clean(){g.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`),this.setStep(e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE),this.emit(e.EventType.KEY_INFO,this.step),this.keysExchanged=!1}start({isOriginator:t,force:n}){const{relayPersistence:i,protocolVersion:o}=this.communicationLayer.remote.state,a=o>=2;i?g.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated"):(g.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${o} isOriginator=${t} step=${this.step} force=${n} relayPersistence=${i} keysExchanged=${this.keysExchanged}`),t?!(this.keysExchanged||this.step!==e.KeyExchangeMessageType.KEY_HANDSHAKE_NONE&&this.step!==e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK)||n?(g.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${n}) -- step=${this.step}`,this.step),this.clean(),this.setStep(e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK),this.communicationLayer.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_SYN,pubkey:this.myPublicKey,v:2}).catch((e=>{g.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN",e)}))):g.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged?"done":"in progress"} -- aborted.`,this.step):this.keysExchanged&&!0!==n?g.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done."):a?this.communicationLayer.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey,v:2}).catch((e=>{g.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK",e)})):(this.communicationLayer.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_START}).catch((e=>{g.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START",e)})),this.clean()))}setStep(t){this.step=t,this.emit(e.EventType.KEY_INFO,t)}checkStep(e){e.length>0&&e.indexOf(this.step.toString())}setRelayPersistence({localKey:e,otherKey:t}){this.otherPublicKey=t,this.myECIES=new T({privateKey:e,debug:this.debug}),this.keysExchanged=!0}setKeysExchanged(e){this.keysExchanged=e}areKeysExchanged(){return this.keysExchanged}getMyPublicKey(){return this.myPublicKey}getOtherPublicKey(){return this.otherPublicKey}setOtherPublicKey(e){g.KeyExchange("[KeyExchange: setOtherPubKey()]",e),this.otherPublicKey=e}encryptMessage(e){if(!this.otherPublicKey)throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.encrypt(e,this.otherPublicKey)}decryptMessage(e){if(!this.otherPublicKey)throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.decrypt(e)}getKeyInfo(){return{ecies:Object.assign(Object.assign({},this.myECIES.getKeyInfo()),{otherPubKey:this.otherPublicKey}),step:this.step,keysExchanged:this.areKeysExchanged()}}toString(){const e={keyInfo:this.getKeyInfo(),keysExchanged:this.keysExchanged,step:this.step};return JSON.stringify(e)}}e.MessageType=void 0,(b=e.MessageType||(e.MessageType={})).TERMINATE="terminate",b.ANSWER="answer",b.OFFER="offer",b.CANDIDATE="candidate",b.JSONRPC="jsonrpc",b.WALLET_INFO="wallet_info",b.WALLET_INIT="wallet_init",b.ORIGINATOR_INFO="originator_info",b.PAUSE="pause",b.OTP="otp",b.AUTHORIZED="authorized",b.PING="ping",b.READY="ready",e.TrackingEvents=void 0,(L=e.TrackingEvents||(e.TrackingEvents={})).REQUEST="sdk_connect_request_started",L.REQUEST_MOBILE="sdk_connect_request_started_mobile",L.RECONNECT="sdk_reconnect_request_started",L.CONNECTED="sdk_connection_established",L.CONNECTED_MOBILE="sdk_connection_established_mobile",L.AUTHORIZED="sdk_connection_authorized",L.REJECTED="sdk_connection_rejected",L.TERMINATED="sdk_connection_terminated",L.DISCONNECTED="sdk_disconnected",L.SDK_USE_EXTENSION="sdk_use_extension",L.SDK_RPC_REQUEST="sdk_rpc_request",L.SDK_RPC_REQUEST_RECEIVED="sdk_rpc_request_received",L.SDK_RPC_REQUEST_DONE="sdk_rpc_request_done",L.SDK_EXTENSION_UTILIZED="sdk_extension_utilized",L.SDK_USE_INAPP_BROWSER="sdk_use_inapp_browser";const H=(n,i,o)=>t.__awaiter(void 0,void 0,void 0,(function*(){var t,a,s,c,r,l;const{remote:d,state:u}=n,{channelId:h,isOriginator:y}=u;if("error_terminated"===i)return g.SocketService(`handleJoinChannelResults: Channel ${h} terminated`),void n.emit(e.EventType.TERMINATE);if(!o)return void g.SocketService(`handleJoinChannelResults: No result for channel ${h}`);const{persistence:E,walletKey:m,rejected:v}=o;if(g.SocketService(`handleJoinChannelResults: Channel ${h} persistence=${E} walletKey=${m} rejected=${v}`),v)return g.SocketService(`handleJoinChannelResults: Channel ${h} rejected`),yield n.remote.disconnect({terminate:!0}),n.remote.emit(e.EventType.REJECTED,{channelId:h}),void n.remote.emitServiceStatusEvent();if(m&&!(null===(t=d.state.channelConfig)||void 0===t?void 0:t.otherKey)){n.getKeyExchange().setOtherPublicKey(m),null===(a=n.state.keyExchange)||void 0===a||a.setKeysExchanged(!0),d.state.ready=!0,d.state.authorized=!0,d.emit(e.EventType.AUTHORIZED);const{communicationLayer:t,storageManager:i}=d.state,o=Object.assign(Object.assign({},d.state.channelConfig),{channelId:null!==(s=d.state.channelId)&&void 0!==s?s:"",validUntil:Date.now()+I,localKey:null==t?void 0:t.getKeyInfo().ecies.private,otherKey:m});n.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}).catch((e=>{})),null===(c=n.state.socket)||void 0===c||c.emit(e.MessageType.PING,{id:h,clientType:y?"dapp":"wallet",context:"on_channel_reconnect",message:""}),yield null==i?void 0:i.persistChannelConfig(o),d.emitServiceStatusEvent(),d.setConnectionStatus(e.ConnectionStatus.LINKED)}E&&(n.emit(e.EventType.CHANNEL_PERSISTENCE),null===(r=n.state.keyExchange)||void 0===r||r.setKeysExchanged(!0),d.state.ready=!0,d.state.authorized=!0,d.emit(e.EventType.AUTHORIZED),_(Object.assign(Object.assign({id:null!=h?h:"",event:y?e.TrackingEvents.CONNECTED:e.TrackingEvents.CONNECTED_MOBILE},n.remote.state.originatorInfo),{sdkVersion:n.remote.state.sdkVersion,commLayer:n.state.communicationLayerPreference,commLayerVersion:f.version,walletVersion:null===(l=n.remote.state.walletInfo)||void 0===l?void 0:l.version}),u.communicationServerUrl).catch((e=>{})))})),j=e=>new Promise((t=>{setTimeout(t,e)})),U=(e,n,...i)=>t.__awaiter(void 0,[e,n,...i],void 0,(function*(e,t,n=200){let i;const o=Date.now();let a=!1;for(;!a;){if(a=Date.now()-o>3e5,i=t[e],void 0!==i.elapsedTime)return i;yield j(n)}throw new Error(`RPC ${e} timed out`)})),Y=n=>t.__awaiter(void 0,void 0,void 0,(function*(){const{state:i}=n,{socket:o,channelId:a,context:s,isOriginator:c,isReconnecting:r}=i;if(r)return g.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping",n),!1;if(!o)return g.SocketService("[SocketService: reconnectSocket()] socket is not defined",n),!1;if(!a)return!1;const{connected:l}=o;i.isReconnecting=!0,i.reconnectionAttempts=0,g.SocketService(`[SocketService: reconnectSocket()] connected=${l} trying to reconnect after socketio disconnection`,n);try{for(;3>i.reconnectionAttempts;){if(g.SocketService(`[SocketService: reconnectSocket()] Attempt ${i.reconnectionAttempts+1} of 3`,n),yield j(200),o.connected)return g.SocketService("Socket already connected --- ping to retrieve messages"),o.emit(e.MessageType.PING,{id:a,clientType:c?"dapp":"wallet",context:"on_channel_config",message:""}),!0;i.resumed=!0,o.connect(),n.emit(e.EventType.SOCKET_RECONNECT);try{if(yield new Promise(((i,r)=>{o.emit(e.EventType.JOIN_CHANNEL,{channelId:a,context:`${s}connect_again`,clientType:c?"dapp":"wallet"},((e,o)=>t.__awaiter(void 0,void 0,void 0,(function*(){try{yield H(n,e,o),i()}catch(e){r(e)}}))))})),yield j(100),o.connected)return g.SocketService(`Reconnection successful on attempt ${i.reconnectionAttempts+1}`),!0}catch(e){g.SocketService(`Error during reconnection attempt ${i.reconnectionAttempts+1}:`,e)}i.reconnectionAttempts+=1,3>i.reconnectionAttempts&&(yield j(200))}return g.SocketService("Failed to reconnect after 3 attempts"),!1}finally{i.isReconnecting=!1,i.reconnectionAttempts=0}}));function G(n,i){return t.__awaiter(this,void 0,void 0,(function*(){var t;const o=null===(t=n.state.keyExchange)||void 0===t?void 0:t.encryptMessage(JSON.stringify(i)),a={id:n.state.channelId,context:n.state.context,clientType:n.state.isOriginator?"dapp":"wallet",message:o,plaintext:n.state.hasPlaintext?JSON.stringify(i):void 0};return g.SocketService(`[SocketService: encryptAndSendMessage()] context=${n.state.context}`,a),i.type===e.MessageType.TERMINATE&&(n.state.manualDisconnect=!0),new Promise(((t,i)=>{var o;null===(o=n.state.socket)||void 0===o||o.emit(e.EventType.MESSAGE,a,((e,n)=>{var o;e&&(g.SocketService(`[SocketService: encryptAndSendMessage()] error=${e}`),i(e)),g.SocketService("[encryptAndSendMessage] response",n),t(null!==(o=null==n?void 0:n.success)&&void 0!==o&&o)}))}))}))}var V;!function(e){e.RPC_CHECK="rpcCheck",e.SKIPPED_RPC="skippedRpc"}(V||(V={}));const z=["eth_sendTransaction","eth_signTypedData","eth_signTransaction","personal_sign","wallet_requestPermissions","wallet_switchEthereumChain","eth_signTypedData_v3","eth_signTypedData_v4","metamask_connectSign","metamask_connectWith","metamask_batch"].map((e=>e.toLowerCase()));function W(n,i){return t.__awaiter(this,void 0,void 0,(function*(){var o,a,c;if(!n.state.channelId)throw g.SocketService("handleSendMessage: no channelId - Create a channel first"),new Error("Create a channel first");if(g.SocketService(`[SocketService: handleSendMessage()] context=${n.state.context} areKeysExchanged=${null===(o=n.state.keyExchange)||void 0===o?void 0:o.areKeysExchanged()}`,i),null===(a=null==i?void 0:i.type)||void 0===a?void 0:a.startsWith("key_handshake"))return function(t,n){var i;g.SocketService(`[SocketService: handleKeyHandshake()] context=${t.state.context}`,n),null===(i=t.state.socket)||void 0===i||i.emit(e.EventType.MESSAGE,{id:t.state.channelId,context:t.state.context,clientType:t.state.isOriginator?"dapp":"wallet",message:n})}(n,i),!0;!function(e,t){var n;if(!(null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged())&&!e.remote.state.relayPersistence)throw g.SocketService(`[SocketService: validateKeyExchange()] context=${e.state.context} ERROR keys not exchanged`,t),new Error("Keys not exchanged BBB")}(n,i),function(t,n){var i;const o=null!==(i=null==n?void 0:n.method)&&void 0!==i?i:"",a=null==n?void 0:n.id;t.state.isOriginator&&a&&(t.state.rpcMethodTracker[a]={id:a,timestamp:Date.now(),method:o},t.emit(e.EventType.RPC_UPDATE,t.state.rpcMethodTracker[a]))}(n,i);const r=yield G(n,i);return n.remote.state.analytics&&n.remote.state.isOriginator&&i.method&&z.includes(i.method.toLowerCase())&&_({id:null!==(c=n.remote.state.channelId)&&void 0!==c?c:"",event:e.TrackingEvents.SDK_RPC_REQUEST,params:{method:i.method,from:"mobile"}},n.remote.state.communicationServerUrl).catch((e=>{})),n.remote.state.isOriginator&&i.method&&O(i.method)&&s.analytics.track("sdk_action_requested",{action:i.method}),function(n,i){return t.__awaiter(this,void 0,void 0,(function*(){var o;const a=null==i?void 0:i.id,s=null!==(o=null==i?void 0:i.method)&&void 0!==o?o:"";if(n.state.isOriginator&&a)try{const o=U(a,n.state.rpcMethodTracker,200).then((e=>({type:V.RPC_CHECK,result:e}))),c=(()=>t.__awaiter(this,void 0,void 0,(function*(){const e=yield(e=>t.__awaiter(void 0,[e],void 0,(function*({rpcId:e,instance:t}){for(;t.state.lastRpcId===e||void 0===t.state.lastRpcId;)yield j(200);return t.state.lastRpcId})))({instance:n,rpcId:a}),i=yield U(e,n.state.rpcMethodTracker,200);return{type:V.SKIPPED_RPC,result:i}})))(),r=yield Promise.race([o,c]);if(r.type===V.RPC_CHECK){const e=r.result;g.SocketService(`[SocketService:handleRpcReplies()] id=${i.id} ${s} ( ${e.elapsedTime} ms)`,e.result)}else{if(r.type!==V.SKIPPED_RPC)throw new Error(`Error handling RPC replies for ${a}`);{const t=Object.assign(Object.assign({},n.state.rpcMethodTracker[a]),{error:new Error("SDK_CONNECTION_ISSUE")});n.emit(e.EventType.RPC_UPDATE,t);const i={data:Object.assign(Object.assign({},t),{jsonrpc:"2.0"}),name:"metamask-provider"};n.emit(e.EventType.MESSAGE,{message:i})}}}catch(e){throw e}}))}(n,i).catch((e=>{})),r}))}const F=[{event:e.EventType.CLIENTS_CONNECTED,handler:function(n,i){return o=>t.__awaiter(this,void 0,void 0,(function*(){var t,o,a,s,c,r,l,d,u,h,y;const E=null!==(o=null===(t=n.remote.state.channelConfig)||void 0===t?void 0:t.relayPersistence)&&void 0!==o&&o;if(g.SocketService(`[SocketService: handleClientsConnected()] context=${n.state.context} on 'clients_connected-${i}' relayPersistence=${E} resumed=${n.state.resumed}  clientsPaused=${n.state.clientsPaused} keysExchanged=${null===(a=n.state.keyExchange)||void 0===a?void 0:a.areKeysExchanged()} isOriginator=${n.state.isOriginator}`),n.emit(e.EventType.CLIENTS_CONNECTED,{isOriginator:n.state.isOriginator,keysExchanged:null===(s=n.state.keyExchange)||void 0===s?void 0:s.areKeysExchanged(),context:n.state.context}),n.state.resumed)n.state.isOriginator||(g.SocketService(`[SocketService: handleClientsConnected()] context=${n.state.context} 'clients_connected' / keysExchanged=${null===(c=n.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged()} -- backward compatibility`),null===(r=n.state.keyExchange)||void 0===r||r.start({isOriginator:null!==(l=n.state.isOriginator)&&void 0!==l&&l})),n.state.resumed=!1;else if(n.state.clientsPaused)g.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");else if(!n.state.isOriginator){const e=!E;g.SocketService(`[SocketService: handleClientsConnected()] context=${n.state.context} on 'clients_connected' / keysExchanged=${null===(d=n.state.keyExchange)||void 0===d?void 0:d.areKeysExchanged()} -- force=${e} -- backward compatibility`),g.SocketService(`[SocketService: handleClientsConnected()] context=${n.state.context} on 'clients_connected' / keysExchanged=${null===(u=n.state.keyExchange)||void 0===u?void 0:u.areKeysExchanged()} -- force=${e} -- backward compatibility`),null===(h=n.state.keyExchange)||void 0===h||h.start({isOriginator:null!==(y=n.state.isOriginator)&&void 0!==y&&y,force:e})}n.state.clientsConnected=!0,n.state.clientsPaused=!1}))}},{event:e.EventType.CHANNEL_CREATED,handler:function(t,n){return i=>{g.SocketService(`[SocketService: handleChannelCreated()] context=${t.state.context} on 'channel_created-${n}'`,i),t.emit(e.EventType.CHANNEL_CREATED,i)}}},{event:e.EventType.CLIENTS_DISCONNECTED,handler:function(t,n){return()=>{var i;t.state.clientsConnected=!1,g.SocketService(`[SocketService: handlesClientsDisconnected()] context=${t.state.context} on 'clients_disconnected-${n}'`),t.remote.state.relayPersistence?g.SocketService(`[SocketService: handlesClientsDisconnected()] context=${t.state.context} on 'clients_disconnected-${n}' - relayPersistence enabled, skipping key exchange cleanup.`):(t.state.isOriginator&&!t.state.clientsPaused&&(null===(i=t.state.keyExchange)||void 0===i||i.clean()),t.emit(e.EventType.CLIENTS_DISCONNECTED,n))}}},{event:e.EventType.CONFIG,handler:function(n,i){return o=>t.__awaiter(this,void 0,void 0,(function*(){var t,a,s;g.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${i}'`,o);const{persistence:c,walletKey:r}=o;n.state.isOriginator&&n.remote.state.channelConfig?(o.walletKey&&!n.remote.state.channelConfig.otherKey&&(g.SocketService(`Setting wallet key ${r}`),n.remote.state.channelConfig.otherKey=r,n.getKeyExchange().setOtherPublicKey(o.walletKey),null===(t=n.state.keyExchange)||void 0===t||t.setKeysExchanged(!0),yield n.remote.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}),yield n.remote.sendMessage({type:e.MessageType.PING}),yield null===(a=n.remote.state.storageManager)||void 0===a?void 0:a.persistChannelConfig(n.remote.state.channelConfig)),!0!==c||n.remote.state.channelConfig.relayPersistence||(g.SocketService(`Setting relay persistence ${c}`),n.remote.state.channelConfig.relayPersistence=c,n.remote.state.relayPersistence=!0,n.remote.emit(e.EventType.CHANNEL_PERSISTENCE),n.remote.state.authorized=!0,n.remote.state.ready=!0,n.remote.emit(e.EventType.AUTHORIZED),yield null===(s=n.remote.state.storageManager)||void 0===s?void 0:s.persistChannelConfig(n.remote.state.channelConfig))):n.state.isOriginator||o.persistence&&(n.remote.state.relayPersistence=!0,n.remote.emit(e.EventType.CHANNEL_PERSISTENCE))}))}},{event:e.EventType.MESSAGE,handler:function(t,n){return i=>{var o,a,c,r,l,d,u,h,y,E,m,v,p,S,C,T,k,K;const{ackId:I,message:x,error:A}=i,N=null!==(o=t.remote.state.relayPersistence)&&void 0!==o&&o;if(g.SocketService(`[SocketService handleMessage()]  relayPersistence=${N}  context=${t.state.context} on 'message' ${n} keysExchanged=${null===(a=t.state.keyExchange)||void 0===a?void 0:a.areKeysExchanged()}`,i),A)throw g.SocketService(`\n      [SocketService handleMessage()] context=${t.state.context}::on 'message' error=${A}`),new Error(A);const R="string"==typeof x;if(!R&&(null==x?void 0:x.type)===e.KeyExchangeMessageType.KEY_HANDSHAKE_START){if(N)return;return g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' received HANDSHAKE_START isOriginator=${t.state.isOriginator}`,x),void(null===(c=t.state.keyExchange)||void 0===c||c.start({isOriginator:null!==(r=t.state.isOriginator)&&void 0!==r&&r,force:!0}))}if(!R&&(null===(l=null==x?void 0:x.type)||void 0===l?void 0:l.startsWith("key_handshake"))){if(N)return;return g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' emit KEY_EXCHANGE`,x),void t.emit(D.KEY_EXCHANGE,{message:x,context:t.state.context})}if(R&&!(null===(d=t.state.keyExchange)||void 0===d?void 0:d.areKeysExchanged())){let n=!1;try{g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' trying to decrypt message`),null===(u=t.state.keyExchange)||void 0===u||u.decryptMessage(x),n=!0}catch(e){g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' error`,e)}if(!n)return t.state.isOriginator?null===(y=t.state.keyExchange)||void 0===y||y.start({isOriginator:null!==(E=t.state.isOriginator)&&void 0!==E&&E}):t.sendMessage({type:e.KeyExchangeMessageType.KEY_HANDSHAKE_START}).catch((e=>{})),void g.SocketService(`Message ignored because invalid key exchange status. step=${null===(m=t.state.keyExchange)||void 0===m?void 0:m.getKeyInfo().step}`,null===(v=t.state.keyExchange)||void 0===v?void 0:v.getKeyInfo(),x);g.SocketService("Invalid key exchange status detected --- updating it."),null===(h=t.state.keyExchange)||void 0===h||h.setKeysExchanged(!0)}else if(!R&&(null==x?void 0:x.type))return void t.emit(e.EventType.MESSAGE,x);if(!R)return void t.emit(e.EventType.MESSAGE,x);const w=null===(p=t.state.keyExchange)||void 0===p?void 0:p.decryptMessage(x),P=JSON.parse(null!=w?w:"{}");if(I&&(null==I?void 0:I.length)>0&&(g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' ackid=${I} channelId=${n}`),null===(S=t.state.socket)||void 0===S||S.emit(e.EventType.MESSAGE_ACK,{ackId:I,channelId:n,clientType:t.state.isOriginator?"dapp":"wallet"})),t.state.clientsPaused=(null==P?void 0:P.type)===e.MessageType.PAUSE,t.state.isOriginator&&P.data){const n=P.data,i=t.state.rpcMethodTracker[n.id];if(i){const o=Date.now()-i.timestamp;g.SocketService(`[SocketService handleMessage()] context=${t.state.context}::on 'message' received answer for id=${n.id} method=${i.method} responseTime=${o}`,P),t.remote.state.analytics&&z.includes(i.method.toLowerCase())&&_(Object.assign(Object.assign({id:null!==(C=t.remote.state.channelId)&&void 0!==C?C:"",event:e.TrackingEvents.SDK_RPC_REQUEST_DONE,sdkVersion:t.remote.state.sdkVersion,commLayerVersion:f.version},t.remote.state.originatorInfo),{walletVersion:null===(T=t.remote.state.walletInfo)||void 0===T?void 0:T.version,params:{method:i.method,from:"mobile"}}),t.remote.state.communicationServerUrl).catch((e=>{})),O(i.method)&&s.analytics.track(n.error?4001===n.error.code?"sdk_action_rejected":"sdk_action_failed":"sdk_action_succeeded",{action:i.method});const a=Object.assign(Object.assign({},i),{result:n.result,error:n.error?{code:null===(k=n.error)||void 0===k?void 0:k.code,message:null===(K=n.error)||void 0===K?void 0:K.message}:void 0,elapsedTime:o});t.state.rpcMethodTracker[n.id]=a,t.emit(e.EventType.RPC_UPDATE,a)}}t.emit(e.EventType.MESSAGE,{message:P})}}},{event:e.EventType.REJECTED,handler:function(n,i){return o=>t.__awaiter(this,void 0,void 0,(function*(){var t;n.state.isOriginator&&!n.remote.state.ready?(g.SocketService(`[SocketService: handleChannelRejected()] context=${n.state.context} channelId=${i} isOriginator=${n.state.isOriginator} ready=${n.remote.state.ready}`,n.remote.state.originatorInfo),_(Object.assign(Object.assign({id:i,event:e.TrackingEvents.REJECTED},n.remote.state.originatorInfo),{sdkVersion:n.remote.state.sdkVersion,commLayer:n.state.communicationLayerPreference,commLayerVersion:f.version,walletVersion:null===(t=n.remote.state.walletInfo)||void 0===t?void 0:t.version}),n.remote.state.communicationServerUrl).catch((e=>{})),s.analytics.track("sdk_connection_rejected",{transport_type:"websocket"}),yield n.remote.disconnect({terminate:!0}),n.remote.emit(e.EventType.REJECTED,{channelId:i}),n.remote.setConnectionStatus(e.ConnectionStatus.DISCONNECTED)):g.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${i} isOriginator=${n.state.isOriginator} ready=${n.remote.state.ready}`)}))}},{event:"clients_waiting_to_join",handler:function(t,n){return i=>{g.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${t.state.context} on 'clients_waiting_to_join-${n}'`,i),t.emit(e.EventType.CLIENTS_WAITING,i)}}}],J=[{event:e.EventType.KEY_INFO,handler:function(t){return n=>{g.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'",n),t.emit(e.EventType.KEY_INFO,n)}}},{event:e.EventType.KEYS_EXCHANGED,handler:function(t){return()=>{var n,i,o;g.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null===(n=t.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`);const{channelConfig:a}=t.remote.state;if(a){const e=t.getKeyExchange().getKeyInfo().ecies;a.localKey=e.private,a.otherKey=e.otherPubKey,t.remote.state.channelConfig=a,null===(i=t.remote.state.storageManager)||void 0===i||i.persistChannelConfig(a).catch((e=>{}))}t.emit(e.EventType.KEYS_EXCHANGED,{keysExchanged:null===(o=t.state.keyExchange)||void 0===o?void 0:o.areKeysExchanged(),isOriginator:t.state.isOriginator});const s={keyInfo:t.getKeyInfo()};t.emit(e.EventType.SERVICE_STATUS,s)}}}];function q(t,n){g.SocketService(`[SocketService: setupChannelListener()] context=${t.state.context} setting socket listeners for channel ${n}...`);const{socket:i}=t.state,{keyExchange:o}=t.state;i&&t.state.isOriginator&&(t.state.debug&&(null==i||i.io.on("error",(e=>{g.SocketService(`[SocketService: setupChannelListener()] context=${t.state.context} socket event=error`,e)})),null==i||i.io.on("reconnect",(e=>{g.SocketService(`[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect`,e),Y(t).catch((e=>{}))})),null==i||i.io.on("reconnect_error",(e=>{g.SocketService(`[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect_error`,e)})),null==i||i.io.on("reconnect_failed",(()=>{g.SocketService(`[SocketService: setupChannelListener()] context=${t.state.context} socket event=reconnect_failed`)}))),null==i||i.on("disconnect",(n=>(g.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${n}' begin recovery...`),function(t){return n=>{g.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${t.state.manualDisconnect}`,n),t.state.manualDisconnect||(t.emit(e.EventType.SOCKET_DISCONNECTED),Y(t).catch((e=>{})))}}(t)(n))))),F.forEach((({event:e,handler:o})=>{null==i||i.on(`${e}-${n}`,o(t,n))})),J.forEach((({event:e,handler:n})=>{null==o||o.on(e,n(t))})),t.state.setupChannelListeners=!0}class B extends c.EventEmitter2{constructor(e){super(),this.state={clientsConnected:!1,clientsPaused:!1,manualDisconnect:!1,lastRpcId:void 0,rpcMethodTracker:{},hasPlaintext:!1,communicationServerUrl:"",focusListenerAdded:!1,removeFocusListener:void 0,isReconnecting:!1,reconnectionAttempts:0},this.options=e;const{reconnect:t,communicationLayerPreference:n,communicationServerUrl:i,context:o,remote:a,logging:s}=e;this.state.resumed=t,this.state.context=o,this.state.isOriginator=a.state.isOriginator,this.state.communicationLayerPreference=n,this.state.debug=!0===(null==s?void 0:s.serviceLayer),this.remote=a,!0===(null==s?void 0:s.serviceLayer)&&h.default.enable("SocketService:Layer"),this.state.communicationServerUrl=i,this.state.hasPlaintext=this.state.communicationServerUrl!==k&&!0===(null==s?void 0:s.plaintext),g.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`),this.initSocket()}initSocket(){var e;const{otherPublicKey:t,ecies:n,logging:i}=this.options,o={autoConnect:!1,transports:K,withCredentials:!0},a=this.state.communicationServerUrl;g.SocketService(`[SocketService: initSocket()] Socket IO url: ${a}`),this.state.socket=l.io(a,o),function(e){if("undefined"!=typeof window&&"undefined"!=typeof document&&(g.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`,e),!e.state.focusListenerAdded)){const t=()=>{g.SocketService("Document has focus --- reconnecting socket"),Y(e).catch((e=>{}))};window.addEventListener("focus",t),e.state.focusListenerAdded=!0,e.state.removeFocusListener=()=>{window.removeEventListener("focus",t),e.state.focusListenerAdded=!1}}}(this);const s={communicationLayer:this,otherPublicKey:t,sendPublicKey:!1,context:null!==(e=this.state.context)&&void 0!==e?e:"",ecies:n,logging:i};this.state.keyExchange=new $(s)}resetKeys(){return this,g.SocketService("[SocketService: resetKeys()] Resetting keys."),void(null===(e=this.state.keyExchange)||void 0===e||e.resetKeys());var e}createChannel(){return t.__awaiter(this,void 0,void 0,(function*(){return function(n){return t.__awaiter(this,void 0,void 0,(function*(){var i,o,a;if(g.SocketService(`[SocketService: createChannel()] context=${n.state.context}`),n.state.socket||n.initSocket(),null===(i=n.state.socket)||void 0===i?void 0:i.connected)throw new Error("socket already connected");null===(o=n.state.socket)||void 0===o||o.connect(),n.state.manualDisconnect=!1,n.state.isOriginator=!0;const s=r.v4();n.state.channelId=s,q(n,s),yield new Promise(((i,o)=>{var a;null===(a=n.state.socket)||void 0===a||a.emit(e.EventType.JOIN_CHANNEL,{channelId:s,context:`${n.state.context}createChannel`,clientType:"dapp"},((e,a)=>t.__awaiter(this,void 0,void 0,(function*(){try{yield H(n,e,a),i()}catch(e){o(e)}}))))}));const c=null===(a=n.state.keyExchange)||void 0===a?void 0:a.getKeyInfo();return{channelId:s,pubKey:(null==c?void 0:c.ecies.public)||"",privKey:(null==c?void 0:c.ecies.private)||""}}))}(this)}))}connectToChannel({channelId:n,withKeyExchange:i=!1,authorized:o}){return function(n){return t.__awaiter(this,arguments,void 0,(function*({options:n,instance:i}){const{channelId:o,authorized:a,withKeyExchange:s}=n,{state:c,remote:r}=i,{isOriginator:l=!1,socket:d,keyExchange:u}=c,{channelConfig:h}=r.state;if(null==d?void 0:d.connected)throw new Error("socket already connected");if(l&&(null==h?void 0:h.relayPersistence)){const{localKey:e,otherKey:t}=h;e&&t&&(null==u||u.setRelayPersistence({localKey:e,otherKey:t}))}return Object.assign(c,{manualDisconnect:!1,withKeyExchange:s,isOriginator:l,channelId:o}),null==d||d.connect(),q(i,o),!l&&a&&(null==u||u.setKeysExchanged(!0),Object.assign(r.state,{ready:!0,authorized:!0})),new Promise((n=>{var s;const r=null===(s=null==u?void 0:u.getKeyInfo())||void 0===s?void 0:s.ecies.public;null==d||d.emit(e.EventType.JOIN_CHANNEL,{channelId:o,context:`${c.context}_connectToChannel`,clientType:l?"dapp":"wallet",publicKey:a&&!l?r:void 0},((e,o)=>t.__awaiter(this,void 0,void 0,(function*(){yield H(i,e,o),n()}))))}))}))}({options:{channelId:n,withKeyExchange:i,authorized:o},instance:this})}getKeyInfo(){return this.state.keyExchange.getKeyInfo()}keyCheck(){var t,n;null===(n=(t=this).state.socket)||void 0===n||n.emit(e.EventType.MESSAGE,{id:t.state.channelId,context:t.state.context,message:{type:e.KeyExchangeMessageType.KEY_HANDSHAKE_CHECK,pubkey:t.getKeyInfo().ecies.otherPubKey}})}getKeyExchange(){return this.state.keyExchange}sendMessage(e){return t.__awaiter(this,void 0,void 0,(function*(){return W(this,e)}))}ping(){return function(n){return t.__awaiter(this,void 0,void 0,(function*(){var t,i;g.SocketService(`[SocketService: ping()] context=${n.state.context} originator=${n.state.isOriginator} keysExchanged=${null===(t=n.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),null===(i=n.state.socket)||void 0===i||i.emit(e.MessageType.PING,{id:n.state.channelId,context:"ping",clientType:n.remote.state.isOriginator?"dapp":"wallet",message:""})}))}(this)}pause(){return function(n){return t.__awaiter(this,void 0,void 0,(function*(){var t,i;g.SocketService(`[SocketService: pause()] context=${n.state.context}`),n.state.manualDisconnect=!0,(null===(t=n.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged())&&(yield n.sendMessage({type:e.MessageType.PAUSE})),null===(i=n.state.socket)||void 0===i||i.disconnect()}))}(this)}isConnected(){var e;return null===(e=this.state.socket)||void 0===e?void 0:e.connected}resume(){return function(n){return t.__awaiter(this,void 0,void 0,(function*(){const{state:i,remote:o}=n,{socket:a,channelId:s,context:c,keyExchange:r,isOriginator:l}=i,{isOriginator:d}=o.state;if(g.SocketService(`[SocketService: resume()] channelId=${s} context=${c} connected=${null==a?void 0:a.connected} manualDisconnect=${i.manualDisconnect} resumed=${i.resumed} keysExchanged=${null==r?void 0:r.areKeysExchanged()}`),!s)throw g.SocketService("[SocketService: resume()] channelId is not defined"),new Error("ChannelId is not defined");(null==a?void 0:a.connected)?(g.SocketService("[SocketService: resume()] already connected."),a.emit(e.MessageType.PING,{id:s,clientType:d?"dapp":"wallet",context:"on_channel_config",message:""}),o.hasRelayPersistence()||(null==r?void 0:r.areKeysExchanged())||(l?yield n.sendMessage({type:e.MessageType.READY}):null==r||r.start({isOriginator:!1}))):(null==a||a.connect(),g.SocketService(`[SocketService: resume()] after connecting socket --\x3e connected=${null==a?void 0:a.connected}`),null==a||a.emit(e.EventType.JOIN_CHANNEL,{channelId:s,context:`${c}_resume`,clientType:d?"dapp":"wallet"},((e,i)=>t.__awaiter(this,void 0,void 0,(function*(){try{yield H(n,e,i)}catch(e){}}))))),i.manualDisconnect=!1,i.resumed=!0}))}(this)}getRPCMethodTracker(){return this.state.rpcMethodTracker}disconnect(e){return function(e,t){var n,i,o,a,s;g.SocketService(`[SocketService: disconnect()] context=${e.state.context}`,t),(null==t?void 0:t.terminate)&&(null===(i=(n=e.state).removeFocusListener)||void 0===i||i.call(n),e.state.channelId=t.channelId,null===(o=e.state.socket)||void 0===o||o.removeAllListeners(),null===(a=e.state.keyExchange)||void 0===a||a.clean(),e.remote.state.ready=!1,e.state.socket=void 0,e.state.rpcMethodTracker={}),e.state.manualDisconnect=!0,null===(s=e.state.socket)||void 0===s||s.disconnect()}(this,e)}}var Z,Q;function X(n){return()=>t.__awaiter(this,void 0,void 0,(function*(){var i,o,a;const{state:s}=n;if(s.authorized)return;yield(()=>t.__awaiter(this,void 0,void 0,(function*(){for(;!s.walletInfo;)yield j(500)})))();const c="7.3".localeCompare((null===(i=s.walletInfo)||void 0===i?void 0:i.version)||"");if(g.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null===(o=s.walletInfo)||void 0===o?void 0:o.version} compareValue=${c}`),1!==c)return;const r=s.platformType===e.PlatformType.MobileWeb||s.platformType===e.PlatformType.ReactNative||s.platformType===e.PlatformType.MetaMaskMobileWebview;g.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${s.platformType} secure=${r} channel=${s.channelId} walletVersion=${null===(a=s.walletInfo)||void 0===a?void 0:a.version}`),r&&(s.authorized=!0,n.emit(e.EventType.AUTHORIZED))}))}function ee(t){return n=>{const{state:i}=t;g.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${i.context} on 'channel_created' channelId=${n}`),t.emit(e.EventType.CHANNEL_CREATED,n)}}function te(t,n){return()=>{var i,o,a,c;const{state:r}=t;g.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${r.channelId} keysExchanged=${null===(o=null===(i=r.communicationLayer)||void 0===i?void 0:i.getKeyInfo())||void 0===o?void 0:o.keysExchanged}`),r.analytics&&_(Object.assign(Object.assign({id:null!==(a=r.channelId)&&void 0!==a?a:"",event:r.reconnection?e.TrackingEvents.RECONNECT:r.isOriginator?e.TrackingEvents.REQUEST:e.TrackingEvents.REQUEST_MOBILE},r.originatorInfo),{commLayer:n,sdkVersion:r.sdkVersion,walletVersion:null===(c=r.walletInfo)||void 0===c?void 0:c.version,commLayerVersion:f.version}),r.communicationServerUrl).catch((e=>{})),r.isOriginator&&!r.reconnection&&s.analytics.track("sdk_connection_established",{transport_type:"websocket"}),r.clientsConnected=!0,r.originatorInfoSent=!1,t.emit(e.EventType.CLIENTS_CONNECTED)}}function ne(t){return n=>{const{state:i}=t;g.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${i.context} on 'clients_disconnected' channelId=${n}`),i.relayPersistence||(i.clientsConnected=!1,i.ready=!1,i.authorized=!1),t.emit(e.EventType.CLIENTS_DISCONNECTED,i.channelId),t.setConnectionStatus(e.ConnectionStatus.DISCONNECTED)}}function ie(t){return n=>{var i;const{state:o}=t;if(g.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${o.context} on 'clients_waiting' numberUsers=${n} ready=${o.ready} autoStarted=${o.originatorConnectStarted}`),t.setConnectionStatus(e.ConnectionStatus.WAITING),t.emit(e.EventType.CLIENTS_WAITING,n),o.originatorConnectStarted){g.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${o.originatorConnectStarted} timeout`,o.autoConnectOptions);const n=(null===(i=o.autoConnectOptions)||void 0===i?void 0:i.timeout)||3e3,a=setTimeout((()=>{g.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${n}) terminate channelConfig`,o.autoConnectOptions),o.originatorConnectStarted=!1,o.ready||t.setConnectionStatus(e.ConnectionStatus.TIMEOUT),clearTimeout(a)}),n)}}}function oe(t,n){return i=>{var o,a,s,c,r,l,d,u;const{state:h}=t;if(g.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${h.context} on commLayer.'keys_exchanged' channel=${h.channelId}`,i),null===(a=null===(o=h.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===a?void 0:a.keysExchanged){const n=Object.assign(Object.assign({},h.channelConfig),{channelId:null!==(s=h.channelId)&&void 0!==s?s:"",validUntil:(null===(c=h.channelConfig)||void 0===c?void 0:c.validUntil)||I,localKey:h.communicationLayer.getKeyInfo().ecies.private,otherKey:h.communicationLayer.getKeyInfo().ecies.otherPubKey});null===(r=h.storageManager)||void 0===r||r.persistChannelConfig(n).catch((e=>{})),t.setConnectionStatus(e.ConnectionStatus.LINKED)}!function(e,t){var n,i,o,a,s,c,r,l;const{state:d}=e;g.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d.channelId}`,t);const u=Object.assign(Object.assign({},d.channelConfig),{channelId:null!==(n=d.channelId)&&void 0!==n?n:"",validUntil:null!==(o=null===(i=d.channelConfig)||void 0===i?void 0:i.validUntil)&&void 0!==o?o:0,relayPersistence:d.relayPersistence,localKey:null===(s=null===(a=d.communicationLayer)||void 0===a?void 0:a.state.keyExchange)||void 0===s?void 0:s.getKeyInfo().ecies.private,otherKey:null===(r=null===(c=d.communicationLayer)||void 0===c?void 0:c.state.keyExchange)||void 0===r?void 0:r.getKeyInfo().ecies.otherPubKey,lastActive:t.getTime()});null===(l=d.storageManager)||void 0===l||l.persistChannelConfig(u)}(t,new Date),h.analytics&&h.channelId&&_(Object.assign(Object.assign({id:h.channelId,event:i.isOriginator?e.TrackingEvents.CONNECTED:e.TrackingEvents.CONNECTED_MOBILE},h.originatorInfo),{sdkVersion:h.sdkVersion,commLayer:n,commLayerVersion:f.version,walletVersion:null===(l=h.walletInfo)||void 0===l?void 0:l.version}),h.communicationServerUrl).catch((e=>{})),h.isOriginator=i.isOriginator,i.isOriginator||(null===(d=h.communicationLayer)||void 0===d||d.sendMessage({type:e.MessageType.READY}),h.ready=!0,h.paused=!1),i.isOriginator&&!h.originatorInfoSent&&(null===(u=h.communicationLayer)||void 0===u||u.sendMessage({type:e.MessageType.ORIGINATOR_INFO,originatorInfo:h.originatorInfo,originator:h.originatorInfo}),h.originatorInfoSent=!0)}}function ae(n){return i=>{let o=i;i.message&&(o=o.message),function(n,i){const{state:o}=i;if(g.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${o.context} on 'message' typeof=${typeof n}`,n),i.state.ready=!0,o.isOriginator||n.type!==e.MessageType.ORIGINATOR_INFO)if(o.isOriginator&&n.type===e.MessageType.WALLET_INFO)!function(e,t){const{state:n}=e;n.walletInfo=t.walletInfo,n.paused=!1}(i,n);else{if(o.isOriginator&&n.type===e.MessageType.WALLET_INIT)(function(n,i){return t.__awaiter(this,void 0,void 0,(function*(){var t,o,a;const{state:s}=n;if(s.isOriginator){const s=i.data||{};if("object"==typeof s&&"accounts"in s&&"chainId"in s&&"walletKey"in s)try{const{channelConfig:i}=n.state;if(g.RemoteCommunication("WALLET_INIT: channelConfig",JSON.stringify(i,null,2)),i){const e=s.accounts,c=s.chainId,r=s.walletKey;let l,d=!1;"deeplinkProtocol"in s&&(d=Boolean(s.deeplinkProtocol),n.state.deeplinkProtocolAvailable=d),"walletVersion"in s&&(l=s.walletVersion),yield null===(t=n.state.storageManager)||void 0===t?void 0:t.persistChannelConfig(Object.assign(Object.assign({},i),{otherKey:r,walletVersion:l,deeplinkProtocolAvailable:d,relayPersistence:!0})),yield null===(o=n.state.storageManager)||void 0===o?void 0:o.persistAccounts(e),yield null===(a=n.state.storageManager)||void 0===a?void 0:a.persistChainId(c)}n.emit(e.EventType.WALLET_INIT,{accounts:s.accounts,chainId:s.chainId})}catch(e){}}}))})(i,n).catch((e=>{g.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`)}));else if(n.type===e.MessageType.TERMINATE)(function(n){return t.__awaiter(this,void 0,void 0,(function*(){const{state:t}=n;t.isOriginator&&(yield de({options:{terminate:!0,sendMessage:!1},instance:n}),n.emit(e.EventType.TERMINATE))}))})(i).catch((e=>{g.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`)}));else if(n.type===e.MessageType.PAUSE)!function(t){const{state:n}=t;n.paused=!0,t.setConnectionStatus(e.ConnectionStatus.PAUSED)}(i);else if(n.type===e.MessageType.READY&&o.isOriginator)!function(t){const{state:n}=t;t.setConnectionStatus(e.ConnectionStatus.LINKED);const i=n.paused;n.paused=!1,t.emit(e.EventType.CLIENTS_READY,{isOriginator:n.isOriginator,walletInfo:n.walletInfo}),i&&(n.authorized=!0,t.emit(e.EventType.AUTHORIZED))}(i);else{if(n.type===e.MessageType.OTP&&o.isOriginator)return void function(t,n){var i;const{state:o}=t;t.emit(e.EventType.OTP,n.otpAnswer),1==="6.6".localeCompare((null===(i=o.walletInfo)||void 0===i?void 0:i.version)||"")&&t.emit(e.EventType.SDK_RPC_CALL,{method:A.ETH_REQUESTACCOUNTS,params:[]})}(i,n);n.type===e.MessageType.AUTHORIZED&&o.isOriginator&&function(t){const{state:n}=t;n.authorized=!0,t.emit(e.EventType.AUTHORIZED)}(i)}i.emit(e.EventType.MESSAGE,n)}else!function(t,n){var i;const{state:o}=t;null===(i=o.communicationLayer)||void 0===i||i.sendMessage({type:e.MessageType.WALLET_INFO,walletInfo:o.walletInfo}),o.originatorInfo=n.originatorInfo||n.originator,t.emit(e.EventType.CLIENTS_READY,{isOriginator:o.isOriginator,originatorInfo:o.originatorInfo}),o.paused=!1}(i,n)}(o,n)}}function se(e){return()=>{const{state:t}=e;g.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"),t.ready=!1,t.authorized=!1,R(t),e.emitServiceStatusEvent({context:"socket_reconnect"})}}function ce(e){return()=>{const{state:t}=e;g.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"),t.ready=!1}}function re(n){return()=>t.__awaiter(this,void 0,void 0,(function*(){var t,i,o,a,s,c,r;const{state:l}=n;g.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${l.context}`),n.state.ready=!0,n.state.clientsConnected=!0,n.state.authorized=!0,n.state.relayPersistence=!0,null===(t=n.state.communicationLayer)||void 0===t||t.getKeyExchange().setKeysExchanged(!0),n.emit(e.EventType.KEYS_EXCHANGED,{keysExchanged:!0,isOriginator:!0}),n.emit(e.EventType.AUTHORIZED),n.emit(e.EventType.CLIENTS_READY),n.emit(e.EventType.CHANNEL_PERSISTENCE);try{l.channelConfig=Object.assign(Object.assign({},l.channelConfig),{localKey:null===(i=l.communicationLayer)||void 0===i?void 0:i.getKeyExchange().getKeyInfo().ecies.private,otherKey:null===(o=l.communicationLayer)||void 0===o?void 0:o.getKeyExchange().getOtherPublicKey(),channelId:null!==(a=l.channelId)&&void 0!==a?a:"",validUntil:null!==(c=null===(s=l.channelConfig)||void 0===s?void 0:s.validUntil)&&void 0!==c?c:I,relayPersistence:!0}),yield null===(r=l.storageManager)||void 0===r?void 0:r.persistChannelConfig(l.channelConfig)}catch(e){}}))}function le({communicationLayerPreference:t,otherPublicKey:n,reconnect:i,ecies:o,communicationServerUrl:a=k,instance:s}){var c,r,l,d,u,h,y,E,m,v,p;const{state:S}=s;if(g.RemoteCommunication("[initCommunicationLayer()] ",JSON.stringify(S,null,2)),t!==e.CommunicationLayerPreference.SOCKET)throw new Error("Invalid communication protocol");S.communicationLayer=new B({communicationLayerPreference:t,otherPublicKey:n,reconnect:i,transports:S.transports,communicationServerUrl:a,context:S.context,ecies:o,logging:S.logging,remote:s});let C="undefined"!=typeof document&&document.URL||"",_="undefined"!=typeof document&&document.title||"";(null===(c=S.dappMetadata)||void 0===c?void 0:c.url)&&(C=S.dappMetadata.url),(null===(r=S.dappMetadata)||void 0===r?void 0:r.name)&&(_=S.dappMetadata.name);const T=null!==(h=null!==(d=null===(l=S.dappMetadata)||void 0===l?void 0:l.name)&&void 0!==d?d:null===(u=S.dappMetadata)||void 0===u?void 0:u.url)&&void 0!==h?h:"N/A",K="undefined"!=typeof window&&void 0!==window.location&&null!==(y=window.location.hostname)&&void 0!==y?y:T,I={url:C,title:_,source:null===(E=S.dappMetadata)||void 0===E?void 0:E.source,dappId:K,anonId:S.anonId,icon:(null===(m=S.dappMetadata)||void 0===m?void 0:m.iconUrl)||(null===(v=S.dappMetadata)||void 0===v?void 0:v.base64Icon),platform:S.platformType,apiVersion:f.version,connector:null===(p=S.dappMetadata)||void 0===p?void 0:p.connector};S.originatorInfo=I;const x={[e.EventType.AUTHORIZED]:X(s),[e.EventType.MESSAGE]:ae(s),[e.EventType.CHANNEL_PERSISTENCE]:re(s),[e.EventType.CLIENTS_CONNECTED]:te(s,t),[e.EventType.KEYS_EXCHANGED]:oe(s,t),[e.EventType.SOCKET_DISCONNECTED]:ce(s),[e.EventType.SOCKET_RECONNECT]:se(s),[e.EventType.CLIENTS_DISCONNECTED]:ne(s),[e.EventType.KEY_INFO]:()=>{},[e.EventType.CHANNEL_CREATED]:ee(s),[e.EventType.CLIENTS_WAITING]:ie(s),[e.EventType.RPC_UPDATE]:t=>{s.emit(e.EventType.RPC_UPDATE,t)}};for(const[e,t]of Object.entries(x))try{S.communicationLayer.on(e,t)}catch(e){}}function de(n){return t.__awaiter(this,arguments,void 0,(function*({options:t,instance:n}){const{state:i}=n;return g.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${i.channelId}`,t),new Promise(((o,a)=>{var s,c,l,d,u,h;(null==t?void 0:t.terminate)?(n.state.ready&&_({id:null!==(s=n.state.channelId)&&void 0!==s?s:"",event:e.TrackingEvents.TERMINATED},n.state.communicationServerUrl).catch((e=>{})),i.ready=!1,i.paused=!1,null===(c=i.storageManager)||void 0===c||c.terminate(null!==(l=i.channelId)&&void 0!==l?l:""),n.state.terminated=!0,t.sendMessage?(null===(d=i.communicationLayer)||void 0===d?void 0:d.getKeyInfo().keysExchanged)&&n.state.communicationLayer&&G(n.state.communicationLayer,{type:e.MessageType.TERMINATE}).then((()=>{o(!0)})).catch((e=>{a(e)})):o(!0),i.authorized=!1,i.relayPersistence=!1,i.channelId=r.v4(),t.channelId=i.channelId,i.channelConfig=void 0,i.originatorConnectStarted=!1,null===(u=i.communicationLayer)||void 0===u||u.disconnect(t),n.setConnectionStatus(e.ConnectionStatus.TERMINATED)):(null===(h=i.communicationLayer)||void 0===h||h.disconnect(t),n.setConnectionStatus(e.ConnectionStatus.DISCONNECTED),o(!0))}))}))}e.CommunicationLayerPreference=void 0,(e.CommunicationLayerPreference||(e.CommunicationLayerPreference={})).SOCKET="socket",e.PlatformType=void 0,(Z=e.PlatformType||(e.PlatformType={})).NonBrowser="nodejs",Z.MetaMaskMobileWebview="in-app-browser",Z.DesktopWeb="web-desktop",Z.MobileWeb="web-mobile",Z.ReactNative="react-native",e.AutoConnectType=void 0,(Q=e.AutoConnectType||(e.AutoConnectType={})).RENEW="renew",Q.LINK="link",e.DEFAULT_SERVER_URL=k,e.DEFAULT_SESSION_TIMEOUT_MS=I,e.ECIES=T,e.RemoteCommunication=class extends c.EventEmitter2{constructor(t){super(),this.state={ready:!1,anonId:"",authorized:!1,isOriginator:!1,terminated:!1,protocolVersion:1,paused:!1,deeplinkProtocolAvailable:!1,platformType:"metamask-mobile",analytics:!1,reconnection:!1,originatorInfoSent:!1,communicationServerUrl:k,context:"",persist:!1,clientsConnected:!1,sessionDuration:I,originatorConnectStarted:!1,debug:!1,_connectionStatus:e.ConnectionStatus.DISCONNECTED},this._options=t;const{anonId:n,platformType:i,communicationLayerPreference:o,otherPublicKey:a,reconnect:s,walletInfo:c,dappMetadata:r,protocolVersion:l,transports:d,context:u,relayPersistence:y,ecies:E,analytics:m=!1,storage:v,sdkVersion:p,communicationServerUrl:S=k,logging:C,autoConnect:_={timeout:x}}=t;this.state.anonId=n,this.state.otherPublicKey=a,this.state.dappMetadata=r,this.state.walletInfo=c,this.state.transports=d,this.state.platformType=i,this.state.analytics=m,this.state.protocolVersion=null!=l?l:1,this.state.isOriginator=!a,this.state.relayPersistence=y,this.state.communicationServerUrl=S,this.state.context=u,this.state.terminated=!1,this.state.sdkVersion=p,this.setMaxListeners(50),this.setConnectionStatus(e.ConnectionStatus.DISCONNECTED),(null==v?void 0:v.duration)&&(this.state.sessionDuration=I),this.state.storageOptions=v,this.state.autoConnectOptions=_,this.state.debug=!0===(null==C?void 0:C.remoteLayer),!0===(null==C?void 0:C.remoteLayer)&&h.default.enable("RemoteCommunication:Layer"),!0===(null==C?void 0:C.serviceLayer)&&h.default.enable("SocketService:Layer"),!0===(null==C?void 0:C.eciesLayer)&&h.default.enable("ECIES:Layer"),!0===(null==C?void 0:C.keyExchangeLayer)&&h.default.enable("KeyExchange:Layer"),this.state.logging=C,(null==v?void 0:v.storageManager)&&(this.state.storageManager=v.storageManager),g.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l} relayPersistence=${y} isOriginator=${this.state.isOriginator} communicationLayerPreference=${o} otherPublicKey=${a} reconnect=${s}`),this.state.isOriginator||le({communicationLayerPreference:o,otherPublicKey:a,reconnect:s,ecies:E,communicationServerUrl:S,instance:this}),this.emitServiceStatusEvent({context:"constructor"})}initFromDappStorage(){return t.__awaiter(this,void 0,void 0,(function*(){var t;if(this.state.storageManager){const n=yield this.state.storageManager.getPersistedChannelConfig({});n&&(this.state.channelConfig=n,this.state.channelId=n.channelId,this.state.deeplinkProtocolAvailable=null!==(t=n.deeplinkProtocolAvailable)&&void 0!==t&&t,n.relayPersistence&&(this.state.authorized=!0,this.state.ready=!0,this.setConnectionStatus(e.ConnectionStatus.LINKED),yield this.connectToChannel({channelId:n.channelId})))}le({communicationLayerPreference:e.CommunicationLayerPreference.SOCKET,otherPublicKey:this.state.otherPublicKey,reconnect:this._options.reconnect,ecies:this._options.ecies,communicationServerUrl:this.state.communicationServerUrl,instance:this})}))}originatorSessionConnect(){return t.__awaiter(this,void 0,void 0,(function*(){return yield function(e){return t.__awaiter(this,void 0,void 0,(function*(){var t;const{state:n}=e;if(!n.storageManager)return void g.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");const i=yield n.storageManager.getPersistedChannelConfig({});if(g.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n.originatorConnectStarted} channelConfig`,i),null===(t=n.communicationLayer)||void 0===t?void 0:t.isConnected())return g.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"),i;if(i){if(i.validUntil>Date.now())return n.channelConfig=i,n.originatorConnectStarted=!0,n.channelId=null==i?void 0:i.channelId,n.reconnection=!0,i;g.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired")}n.originatorConnectStarted=!1}))}(this)}))}generateChannelIdConnect(){return t.__awaiter(this,void 0,void 0,(function*(){return function(e){return t.__awaiter(this,void 0,void 0,(function*(){var t,n,i,o,a,s;if(!e.communicationLayer)throw new Error("communication layer not initialized");if(e.ready)throw new Error("Channel already connected");if(e.channelId&&(null===(t=e.communicationLayer)||void 0===t?void 0:t.isConnected()))return e.channelConfig=Object.assign(Object.assign({},e.channelConfig),{channelId:e.channelId,validUntil:Date.now()+e.sessionDuration}),null===(n=e.storageManager)||void 0===n||n.persistChannelConfig(e.channelConfig),{channelId:e.channelId,privKey:null===(o=null===(i=e.communicationLayer)||void 0===i?void 0:i.getKeyInfo())||void 0===o?void 0:o.ecies.private,pubKey:null===(s=null===(a=e.communicationLayer)||void 0===a?void 0:a.getKeyInfo())||void 0===s?void 0:s.ecies.public};g.RemoteCommunication("[RemoteCommunication: generateChannelId()]");const c=yield e.communicationLayer.createChannel();g.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created",c);const r=Object.assign(Object.assign({},e.channelConfig),{channelId:c.channelId,localKey:c.privKey,validUntil:Date.now()+e.sessionDuration});return e.channelId=c.channelId,e.channelConfig=r,{channelId:e.channelId,pubKey:c.pubKey,privKey:c.privKey}}))}(this.state)}))}clean(){return R(this.state)}connectToChannel({channelId:e,withKeyExchange:n,authorized:i}){return function(e){return t.__awaiter(this,arguments,void 0,(function*({channelId:e,withKeyExchange:t,authorized:n,state:i}){var o,a,s;if(!r.validate(e))throw g.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${i.context} invalid channel channelId=${e}`),new Error(`Invalid channel ${e}`);if(g.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${i.context} channelId=${e} withKeyExchange=${t}`),null===(o=i.communicationLayer)||void 0===o?void 0:o.isConnected())return void g.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${i.context} already connected - interrupt connection.`);i.channelId=e,yield null===(a=i.communicationLayer)||void 0===a?void 0:a.connectToChannel({channelId:e,authorized:n,withKeyExchange:t});const c=Object.assign(Object.assign({},i.channelConfig),{channelId:e,validUntil:Date.now()+i.sessionDuration});i.channelConfig=c,null===(s=i.storageManager)||void 0===s||s.persistChannelConfig(c)}))}({channelId:e,authorized:i,withKeyExchange:n,state:this.state})}sendMessage(n){return t.__awaiter(this,void 0,void 0,(function*(){const i=this.state.isOriginator&&n.method&&O(n.method);i&&s.analytics.track("sdk_action_requested",{action:n.method});try{return yield function(n,i){return t.__awaiter(this,void 0,void 0,(function*(){var o,a;const{state:s}=n;g.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s.context} paused=${s.paused} ready=${s.ready} relayPersistence=${s.relayPersistence} authorized=${s.authorized} socket=${null===(o=s.communicationLayer)||void 0===o?void 0:o.isConnected()} clientsConnected=${s.clientsConnected} status=${s._connectionStatus}`,i),s.relayPersistence||s.ready&&(null===(a=s.communicationLayer)||void 0===a?void 0:a.isConnected())&&s.clientsConnected||(g.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s.context}  SKIP message waiting for MM mobile readiness.`),yield new Promise((t=>{n.once(e.EventType.CLIENTS_READY,t)})),g.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s.context}  AFTER SKIP / READY -- sending pending message`));try{const o=yield function(n,i){return t.__awaiter(this,void 0,void 0,(function*(){return new Promise((t=>{var o;const{state:a}=n;g.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${a.context} ready=${a.ready} authorized=${a.authorized} method=${i.method}`),!a.isOriginator||a.authorized||a.relayPersistence?null===(o=a.communicationLayer)||void 0===o||o.sendMessage(i).then((e=>{t(e)})).catch((e=>{t(!1)})):n.once(e.EventType.AUTHORIZED,(()=>{var e;g.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${a.context}  AFTER SKIP / AUTHORIZED -- sending pending message`),null===(e=a.communicationLayer)||void 0===e||e.sendMessage(i).then((e=>{t(e)})).catch((e=>{t(!1)}))}))}))}))}(n,i);return o}catch(e){throw e}}))}(this,n)}catch(e){throw i&&s.analytics.track("sdk_action_failed",{action:n.method}),e}}))}testStorage(){return t.__awaiter(this,void 0,void 0,(function*(){return function(e){return t.__awaiter(this,void 0,void 0,(function*(){var t;const n=yield null===(t=e.storageManager)||void 0===t?void 0:t.getPersistedChannelConfig();g.RemoteCommunication("[RemoteCommunication: testStorage()] res",n)}))}(this.state)}))}hasDeeplinkProtocol(){return this.state.deeplinkProtocolAvailable}getChannelConfig(){return this.state.channelConfig}isReady(){return this.state.ready}isConnected(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.isConnected()}isAuthorized(){return this.state.authorized}isPaused(){return this.state.paused}getCommunicationLayer(){return this.state.communicationLayer}ping(){return t.__awaiter(this,void 0,void 0,(function*(){var e;g.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`),yield null===(e=this.state.communicationLayer)||void 0===e?void 0:e.ping()}))}testLogger(){g.RemoteCommunication(`testLogger() channel=${this.state.channelId}`),g.SocketService(`testLogger() channel=${this.state.channelId}`),g.Ecies(`testLogger() channel=${this.state.channelId}`),g.KeyExchange(`testLogger() channel=${this.state.channelId}`)}keyCheck(){var e;g.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.keyCheck()}setConnectionStatus(t){this.state._connectionStatus!==t&&(this.state._connectionStatus=t,this.emit(e.EventType.CONNECTION_STATUS,t),this.emitServiceStatusEvent({context:"setConnectionStatus"}))}emitServiceStatusEvent(t={}){this.emit(e.EventType.SERVICE_STATUS,this.getServiceStatus())}getConnectionStatus(){return this.state._connectionStatus}getServiceStatus(){return{originatorInfo:this.state.originatorInfo,keyInfo:this.getKeyInfo(),connectionStatus:this.state._connectionStatus,channelConfig:this.state.channelConfig,channelId:this.state.channelId}}getKeyInfo(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getKeyInfo()}resetKeys(){var e;null===(e=this.state.communicationLayer)||void 0===e||e.resetKeys()}setOtherPublicKey(e){var t;const n=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange();if(!n)throw new Error("KeyExchange is not initialized.");n.getOtherPublicKey()!==e&&n.setOtherPublicKey(e)}pause(){return t.__awaiter(this,void 0,void 0,(function*(){var t;g.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`),yield null===(t=this.state.communicationLayer)||void 0===t?void 0:t.pause(),this.setConnectionStatus(e.ConnectionStatus.PAUSED)}))}getVersion(){return f.version}hasRelayPersistence(){var e;return null!==(e=this.state.relayPersistence)&&void 0!==e&&e}resume(){return t.__awaiter(this,void 0,void 0,(function*(){return function(n){return t.__awaiter(this,void 0,void 0,(function*(){var t;const{state:i}=n;g.RemoteCommunication(`[RemoteCommunication: resume()] channel=${i.channelId}`),yield null===(t=i.communicationLayer)||void 0===t?void 0:t.resume(),n.setConnectionStatus(e.ConnectionStatus.LINKED)}))}(this)}))}encrypt(e){var t,n,i;const o=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange(),a=null==o?void 0:o.getOtherPublicKey();if(!a)throw new Error("KeyExchange not completed");return null===(i=null===(n=this.state.communicationLayer)||void 0===n?void 0:n.state.eciesInstance)||void 0===i?void 0:i.encrypt(e,a)}decrypt(e){var t,n,i;if(!(null===(t=this.state.communicationLayer)||void 0===t?void 0:t.state.eciesInstance))throw new Error("ECIES instance is not initialized");return null===(i=null===(n=this.state.communicationLayer)||void 0===n?void 0:n.state.eciesInstance)||void 0===i?void 0:i.decrypt(e)}getChannelId(){return this.state.channelId}getRPCMethodTracker(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getRPCMethodTracker()}reject({channelId:n}){return function(n){return t.__awaiter(this,arguments,void 0,(function*({channelId:t,state:n}){var i,o,a;if(!r.validate(t))throw g.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${n.context} invalid channel channelId=${t}`),new Error(`Invalid channel ${t}`);if(n.isOriginator)return void g.RemoteCommunication(`[RemoteCommunication: reject()] context=${n.context} isOriginator=${n.isOriginator} channelId=${t}`);const{socket:s}=null!==(o=null===(i=n.communicationLayer)||void 0===i?void 0:i.state)&&void 0!==o?o:{};(null==s?void 0:s.connected)||(g.RemoteCommunication(`[RemoteCommunication: reject()] context=${n.context} socket already connected`),null==s||s.connect()),_(Object.assign(Object.assign({id:t,event:e.TrackingEvents.REJECTED},n.originatorInfo),{sdkVersion:n.sdkVersion,commLayerVersion:f.version,walletVersion:null===(a=n.walletInfo)||void 0===a?void 0:a.version}),n.communicationServerUrl).catch((e=>{})),yield new Promise(((i,o)=>{null==s||s.emit(e.EventType.REJECTED,{channelId:t},((e,t)=>{g.RemoteCommunication(`[RemoteCommunication: reject()] context=${n.context} socket=${null==s?void 0:s.id}`,{error:e,response:t}),e?o(e):i(t)}))}))}))}({channelId:n,state:this.state})}disconnect(e){return t.__awaiter(this,void 0,void 0,(function*(){return de({options:e,instance:this})}))}},e.SendAnalytics=_,e.SocketService=B,e.isAnalyticsTrackedRpcMethod=O}));
//# sourceMappingURL=metamask-sdk-communication-layer.js.map
