import*as e from"node:crypto";const t=e&&typeof e==`object`&&`webcrypto`in e?e.webcrypto:e&&typeof e==`object`&&`randomBytes`in e?e:void 0;function n(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name===`Uint8Array`}function r(e){if(!Number.isSafeInteger(e)||e<0)throw Error(`positive integer expected, got `+e)}function i(e,...t){if(!n(e))throw Error(`Uint8Array expected`);if(t.length>0&&!t.includes(e.length))throw Error(`Uint8Array expected of length `+t+`, got length=`+e.length)}function a(e){if(typeof e!=`function`||typeof e.create!=`function`)throw Error(`Hash should be wrapped by utils.createHasher`);r(e.outputLen),r(e.blockLen)}function o(e,t=!0){if(e.destroyed)throw Error(`Hash instance has been destroyed`);if(t&&e.finished)throw Error(`Hash#digest() has already been called`)}function s(e,t){i(e);let n=t.outputLen;if(e.length<n)throw Error(`digestInto() expects output buffer of length at least `+n)}function c(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function l(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function u(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function d(e,t){return e<<32-t|e>>>t}const f=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function p(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function m(e){for(let t=0;t<e.length;t++)e[t]=p(e[t]);return e}const h=f?e=>e:m;function ee(e){if(typeof e!=`string`)throw Error(`string expected`);return new Uint8Array(new TextEncoder().encode(e))}function g(e){return typeof e==`string`&&(e=ee(e)),i(e),e}function te(...e){let t=0;for(let n=0;n<e.length;n++){let r=e[n];i(r),t+=r.length}let n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){let i=e[t];n.set(i,r),r+=i.length}return n}var ne=class{};function _(e){let t=t=>e().update(g(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function v(e=32){if(t&&typeof t.getRandomValues==`function`)return t.getRandomValues(new Uint8Array(e));if(t&&typeof t.randomBytes==`function`)return Uint8Array.from(t.randomBytes(e));throw Error(`crypto.getRandomValues must be defined`)}const y=BigInt(2**32-1),b=BigInt(32);function x(e,t=!1){return t?{h:Number(e&y),l:Number(e>>b&y)}:{h:Number(e>>b&y)|0,l:Number(e&y)|0}}function re(e,t=!1){let n=e.length,r=new Uint32Array(n),i=new Uint32Array(n);for(let a=0;a<n;a++){let{h:n,l:o}=x(e[a],t);[r[a],i[a]]=[n,o]}return[r,i]}const S=(e,t,n)=>e>>>n,ie=(e,t,n)=>e<<32-n|t>>>n,ae=(e,t,n)=>e>>>n|t<<32-n,oe=(e,t,n)=>e<<32-n|t>>>n,se=(e,t,n)=>e<<64-n|t>>>n-32,C=(e,t,n)=>e>>>n-32|t<<64-n,w=(e,t,n)=>e<<n|t>>>32-n,T=(e,t,n)=>t<<n|e>>>32-n,E=(e,t,n)=>t<<n-32|e>>>64-n,D=(e,t,n)=>e<<n-32|t>>>64-n;function O(e,t,n,r){let i=(t>>>0)+(r>>>0);return{h:e+n+(i/2**32|0)|0,l:i|0}}const k=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),A=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,j=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),M=(e,t,n,r,i)=>t+n+r+i+(e/2**32|0)|0,N=(e,t,n,r,i)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(i>>>0),P=(e,t,n,r,i,a)=>t+n+r+i+a+(e/2**32|0)|0,F=BigInt(0),I=BigInt(1);function L(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name===`Uint8Array`}function R(e){if(!L(e))throw Error(`Uint8Array expected`)}function z(e,t){if(typeof t!=`boolean`)throw Error(e+` boolean expected, got `+t)}function B(e){let t=e.toString(16);return t.length&1?`0`+t:t}function V(e){if(typeof e!=`string`)throw Error(`hex string expected, got `+typeof e);return e===``?F:BigInt(`0x`+e)}const H=typeof Uint8Array.from([]).toHex==`function`&&typeof Uint8Array.fromHex==`function`,U=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,`0`));function W(e){if(R(e),H)return e.toHex();let t=``;for(let n=0;n<e.length;n++)t+=U[e[n]];return t}const G={_0:48,_9:57,A:65,F:70,a:97,f:102};function K(e){if(e>=G._0&&e<=G._9)return e-G._0;if(e>=G.A&&e<=G.F)return e-(G.A-10);if(e>=G.a&&e<=G.f)return e-(G.a-10)}function q(e){if(typeof e!=`string`)throw Error(`hex string expected, got `+typeof e);if(H)return Uint8Array.fromHex(e);let t=e.length,n=t/2;if(t%2)throw Error(`hex string expected, got unpadded hex of length `+t);let r=new Uint8Array(n);for(let t=0,i=0;t<n;t++,i+=2){let n=K(e.charCodeAt(i)),a=K(e.charCodeAt(i+1));if(n===void 0||a===void 0){let t=e[i]+e[i+1];throw Error(`hex string expected, got non-hex character "`+t+`" at index `+i)}r[t]=n*16+a}return r}function ce(e){return V(W(e))}function le(e){return R(e),V(W(Uint8Array.from(e).reverse()))}function J(e,t){return q(e.toString(16).padStart(t*2,`0`))}function ue(e,t){return J(e,t).reverse()}function de(e,t,n){let r;if(typeof t==`string`)try{r=q(t)}catch(t){throw Error(e+` must be hex string or Uint8Array, cause: `+t)}else if(L(t))r=Uint8Array.from(t);else throw Error(e+` must be hex string or Uint8Array`);let i=r.length;if(typeof n==`number`&&i!==n)throw Error(e+` of length `+n+` expected, got `+i);return r}function Y(...e){let t=0;for(let n=0;n<e.length;n++){let r=e[n];R(r),t+=r.length}let n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){let i=e[t];n.set(i,r),r+=i.length}return n}const X=e=>typeof e==`bigint`&&F<=e;function Z(e,t,n){return X(e)&&X(t)&&X(n)&&t<=e&&e<n}function fe(e,t,n,r){if(!Z(t,n,r))throw Error(`expected valid `+e+`: `+n+` <= n < `+r+`, got `+t)}function pe(e){let t;for(t=0;e>F;e>>=I,t+=1);return t}const me=e=>(I<<BigInt(e))-I,Q=e=>new Uint8Array(e),$=e=>Uint8Array.from(e);function he(e,t,n){if(typeof e!=`number`||e<2)throw Error(`hashLen must be a number`);if(typeof t!=`number`||t<2)throw Error(`qByteLen must be a number`);if(typeof n!=`function`)throw Error(`hmacFn must be a function`);let r=Q(e),i=Q(e),a=0,o=()=>{r.fill(1),i.fill(0),a=0},s=(...e)=>n(i,r,...e),c=(e=Q(0))=>{i=s($([0]),e),r=s(),e.length!==0&&(i=s($([1]),e),r=s())},l=()=>{if(a++>=1e3)throw Error(`drbg: tried 1000 values`);let e=0,n=[];for(;e<t;){r=s();let t=r.slice();n.push(t),e+=r.length}return Y(...n)};return(e,t)=>{o(),c(e);let n;for(;!(n=t(l()));)c();return o(),n}}const ge={bigint:e=>typeof e==`bigint`,function:e=>typeof e==`function`,boolean:e=>typeof e==`boolean`,string:e=>typeof e==`string`,stringOrUint8Array:e=>typeof e==`string`||L(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e==`function`&&Number.isSafeInteger(e.outputLen)};function _e(e,t,n={}){let r=(t,n,r)=>{let i=ge[n];if(typeof i!=`function`)throw Error(`invalid validator function`);let a=e[t];if(!(r&&a===void 0)&&!i(a,e))throw Error(`param `+String(t)+` is invalid. Expected `+n+`, got `+a)};for(let[e,n]of Object.entries(t))r(e,n,!1);for(let[e,t]of Object.entries(n))r(e,t,!0);return e}function ve(e){let t=new WeakMap;return(n,...r)=>{let i=t.get(n);if(i!==void 0)return i;let a=e(n,...r);return t.set(n,a),a}}export{ne as Hash,fe as aInRange,z as abool,i as abytes,O as add,A as add3H,k as add3L,M as add4H,j as add4L,P as add5H,N as add5L,o as aexists,a as ahash,r as anumber,s as aoutput,pe as bitLen,me as bitMask,W as bytesToHex,ce as bytesToNumberBE,le as bytesToNumberLE,l as clean,Y as concatBytes,te as concatBytes$1,_ as createHasher,he as createHmacDrbg,u as createView,de as ensureBytes,q as hexToBytes,Z as inRange,L as isBytes,ve as memoized,J as numberToBytesBE,ue as numberToBytesLE,B as numberToHexUnpadded,v as randomBytes,E as rotlBH,D as rotlBL,w as rotlSH,T as rotlSL,d as rotr,se as rotrBH,C as rotrBL,ae as rotrSH,oe as rotrSL,S as shrSH,ie as shrSL,re as split,h as swap32IfBE,g as toBytes,c as u32,_e as validateObject};