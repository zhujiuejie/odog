import"./utils-DlSZ4OeX.js";import{AbiErrorInputsNotFoundError as e,AbiErrorNotFoundError as t,AbiFunctionNotFoundError as n,AbiFunctionOutputsNotFoundError as r,AbiFunctionSignatureNotFoundError as i,BaseError as a,HttpRequestError as o,InvalidArrayError as s,batchGatewayAbi as c,call as l,concat as u,concatHex as d,decodeAbiParameters as f,decodeErrorResult as p,encodeAbiParameters as m,formatAbiItem as h,getAbiItem as g,getUrl as _,isAddressEqual as v,isHex as y,slice as b,solidityError as x,stringify as S,toFunctionSelector as C}from"./isAddressEqual-CFvy5LFG.js";var w=class extends a{constructor({callbackSelector:e,cause:t,data:n,extraData:r,sender:i,urls:a}){super(t.shortMessage||`An error occurred while fetching for an offchain result.`,{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?``:[],`Offchain Gateway Call:`,a&&[`  Gateway URL(s):`,...a.map(e=>`    ${_(e)}`)],`  Sender: ${i}`,`  Data: ${n}`,`  Callback selector: ${e}`,`  Extra data: ${r}`].flat(),name:`OffchainLookupError`})}},T=class extends a{constructor({result:e,url:t}){super(`Offchain gateway response is malformed. Response data must be a hex value.`,{metaMessages:[`Gateway URL: ${_(t)}`,`Response: ${S(e)}`],name:`OffchainLookupResponseMalformedError`})}},E=class extends a{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:`OffchainLookupSenderMismatchError`})}};function D(e){let{abi:t,data:n}=e,r=b(n,0,4),a=t.find(e=>e.type===`function`&&r===C(h(e)));if(!a)throw new i(r,{docsPath:`/docs/contract/decodeFunctionData`});return{functionName:a.name,args:`inputs`in a&&a.inputs&&a.inputs.length>0?f(a.inputs,b(n,4)):void 0}}const O=`/docs/contract/encodeErrorResult`;function k(n){let{abi:r,errorName:i,args:a}=n,o=r[0];if(i){let e=g({abi:r,args:a,name:i});if(!e)throw new t(i,{docsPath:O});o=e}if(o.type!==`error`)throw new t(void 0,{docsPath:O});let s=h(o),c=C(s),l=`0x`;if(a&&a.length>0){if(!o.inputs)throw new e(o.name,{docsPath:O});l=m(o.inputs,a)}return d([c,l])}const A=`/docs/contract/encodeFunctionResult`;function j(e){let{abi:t,functionName:i,result:a}=e,o=t[0];if(i){let e=g({abi:t,name:i});if(!e)throw new n(i,{docsPath:A});o=e}if(o.type!==`function`)throw new n(void 0,{docsPath:A});if(!o.outputs)throw new r(o.name,{docsPath:A});let c=(()=>{if(o.outputs.length===0)return[];if(o.outputs.length===1)return[a];if(Array.isArray(a))return a;throw new s(a)})();return m(o.outputs,c)}const M=`x-batch-gateway:true`;async function N(e){let{data:t,ccipRequest:n}=e,{args:[r]}=D({abi:c,data:t}),i=[],a=[];return await Promise.all(r.map(async(e,t)=>{try{a[t]=e.urls.includes(M)?await N({data:e.data,ccipRequest:n}):await n(e),i[t]=!1}catch(e){i[t]=!0,a[t]=P(e)}})),j({abi:c,functionName:`query`,result:[i,a]})}function P(e){return e.name===`HttpRequestError`&&e.status?k({abi:c,errorName:`HttpError`,args:[e.status,e.shortMessage]}):k({abi:[x],errorName:`Error`,args:[`shortMessage`in e?e.shortMessage:e.message]})}const F=`0x556f1830`,I={name:`OffchainLookup`,type:`error`,inputs:[{name:`sender`,type:`address`},{name:`urls`,type:`string[]`},{name:`callData`,type:`bytes`},{name:`callbackFunction`,type:`bytes4`},{name:`extraData`,type:`bytes`}]};async function L(e,{blockNumber:t,blockTag:n,data:r,to:i}){let{args:a}=p({data:r,abi:[I]}),[o,s,c,d,f]=a,{ccipRead:h}=e,g=h&&typeof h?.request==`function`?h.request:R;try{if(!v(i,o))throw new E({sender:o,to:i});let r=s.includes(M)?await N({data:c,ccipRequest:g}):await g({data:c,sender:o,urls:s}),{data:a}=await l(e,{blockNumber:t,blockTag:n,data:u([d,m([{type:`bytes`},{type:`bytes`}],[r,f])]),to:i});return a}catch(e){throw new w({callbackSelector:d,cause:e,data:r,extraData:f,sender:o,urls:s})}}async function R({data:e,sender:t,urls:n}){let r=Error(`An unknown error occurred.`);for(let i=0;i<n.length;i++){let a=n[i],s=a.includes(`{data}`)?`GET`:`POST`,c=s===`POST`?{data:e,sender:t}:void 0,l=s===`POST`?{"Content-Type":`application/json`}:{};try{let n=await fetch(a.replace(`{sender}`,t.toLowerCase()).replace(`{data}`,e),{body:JSON.stringify(c),headers:l,method:s}),i;if(i=n.headers.get(`Content-Type`)?.startsWith(`application/json`)?(await n.json()).data:await n.text(),!n.ok){r=new o({body:c,details:i?.error?S(i.error):n.statusText,headers:n.headers,status:n.status,url:a});continue}if(!y(i)){r=new T({result:i,url:a});continue}return i}catch(e){r=new o({body:c,details:e.message,url:a})}}throw r}export{L as offchainLookup,F as offchainLookupSignature};