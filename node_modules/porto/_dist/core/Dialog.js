import * as Provider from 'ox/Provider';
import * as IO from './internal/intersectionObserver.js';
import { logger } from './internal/logger.js';
import * as UserAgent from './internal/userAgent.js';
import * as Messenger from './Messenger.js';
export const hostUrls = {
    local: 'http://localhost:5175/dialog/',
    prod: 'https://id.porto.sh/dialog',
    stg: 'https://stg.id.porto.sh/dialog',
};
/**
 * Instantiates a dialog.
 *
 * @param dialog - Dialog.
 * @returns Instantiated dialog.
 */
export function from(dialog) {
    return dialog;
}
/**
 * Instantiates an iframe dialog.
 *
 * @returns iframe dialog.
 */
export function iframe(options = {}) {
    const { skipProtocolCheck, skipUnsupported } = options;
    // Safari does not support WebAuthn credential creation in iframes.
    // Fall back to popup dialog.
    // Tracking: https://github.com/WebKit/standards-positions/issues/304
    const includesUnsupported = (requests) => !skipUnsupported &&
        UserAgent.isSafari() &&
        requests?.some((x) => ['wallet_connect', 'eth_requestAccounts'].includes(x.method));
    if (typeof window === 'undefined')
        return noop();
    return from({
        name: 'iframe',
        setup(parameters) {
            const { host, internal, theme, themeController } = parameters;
            const { store } = internal;
            const fallback = popup().setup(parameters);
            let open = false;
            const hostUrl = new URL(host);
            const root = document.createElement('dialog');
            root.dataset.porto = '';
            root.setAttribute('role', 'dialog');
            root.setAttribute('aria-closed', 'true');
            root.setAttribute('aria-label', 'Porto Wallet');
            root.setAttribute('hidden', 'until-found');
            Object.assign(root.style, {
                background: 'transparent',
                border: '0',
                outline: '0',
                padding: '0',
                position: 'fixed',
            });
            document.body.appendChild(root);
            const iframe = document.createElement('iframe');
            iframe.setAttribute('data-testid', 'porto');
            const iframeAllow = [
                `publickey-credentials-get ${hostUrl.origin}`,
                `publickey-credentials-create ${hostUrl.origin}`,
            ];
            if (!UserAgent.isFirefox())
                iframeAllow.push('clipboard-write');
            iframe.setAttribute('allow', iframeAllow.join('; '));
            iframe.setAttribute('tabindex', '0');
            iframe.setAttribute('sandbox', 'allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox');
            iframe.setAttribute('src', getDialogUrl(host));
            iframe.setAttribute('title', 'Porto');
            Object.assign(iframe.style, {
                backgroundColor: 'transparent',
                border: '0',
                colorScheme: 'light dark',
                height: '100%',
                left: '0',
                position: 'fixed',
                top: '0',
                width: '100%',
            });
            const style = document.createElement('style');
            style.innerHTML = `
        dialog[data-porto]::backdrop {
          background: transparent!important;
        }
      `;
            root.appendChild(style);
            root.appendChild(iframe);
            const messenger = Messenger.bridge({
                from: Messenger.fromWindow(window, { targetOrigin: hostUrl.origin }),
                to: Messenger.fromWindow(iframe.contentWindow, {
                    targetOrigin: hostUrl.origin,
                }),
                waitForReady: true,
            });
            themeController?._setup(messenger, true);
            const drawerModeQuery = window.matchMedia('(max-width: 460px)');
            const onDrawerModeChange = () => {
                messenger.send('__internal', {
                    type: 'resize',
                    // 460 = drawer mode, 461 = floating mode
                    width: drawerModeQuery.matches ? 460 : 461,
                });
            };
            drawerModeQuery.addEventListener('change', onDrawerModeChange);
            messenger.on('ready', (options) => {
                const chainIds = parameters.internal.store.getState().chainIds;
                // Derive the compatible chain IDs between the dialog and the application.
                let compatibleChainIds = chainIds.filter((id) => options.chainIds.includes(id));
                // If the consumer has no compatible chain IDs with the dialog,
                // fall back to the dialog's chain IDs.
                if (compatibleChainIds.length === 0)
                    compatibleChainIds = options.chainIds;
                store.setState((x) => ({
                    ...x,
                    chainIds: compatibleChainIds,
                }));
                messenger.send('__internal', {
                    chainIds: compatibleChainIds,
                    mode: 'iframe',
                    referrer: getReferrer(),
                    theme,
                    type: 'init',
                });
                onDrawerModeChange();
            });
            messenger.on('rpc-response', (response) => {
                if (includesUnsupported([response._request])) {
                    // reload iframe to rehydrate storage state if an
                    // unsupported request routed via another renderer.
                    const src = iframe.src;
                    iframe.src = src;
                }
                handleResponse(store, response);
            });
            messenger.on('__internal', (payload) => {
                if (payload.type === 'switch' && payload.mode === 'popup') {
                    fallback.open();
                    fallback.syncRequests(store.getState().requestQueue);
                }
            });
            let bodyStyle = null;
            // store the opening element to restore the focus
            let opener = null;
            const onBlur = () => handleBlur(store);
            const onEscape = (event) => {
                if (event.key === 'Escape')
                    handleBlur(store);
            };
            // 1password extension adds `inert` attribute to `dialog` and inserts
            // itself (`<com-1password-notification />`) there rendering itself unusable:
            // watch for `inert` on `dialog` and remove it
            const inertObserver = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    if (mutation.type !== 'attributes')
                        continue;
                    const name = mutation.attributeName;
                    if (!name)
                        continue;
                    if (name !== 'inert')
                        continue;
                    root.removeAttribute(name);
                }
            });
            inertObserver.observe(root, {
                attributeOldValue: true,
                attributes: true,
            });
            // dialog/page interactivity (no visibility change)
            let dialogActive = false;
            const activatePage = () => {
                if (!dialogActive)
                    return;
                dialogActive = false;
                root.removeEventListener('click', onBlur);
                document.removeEventListener('keydown', onEscape);
                root.style.pointerEvents = 'none';
                opener?.focus();
                opener = null;
                Object.assign(document.body.style, bodyStyle ?? '');
                // firefox: explicitly restore/clear `overflow` directly
                document.body.style.overflow = bodyStyle?.overflow ?? '';
            };
            const activateDialog = () => {
                if (dialogActive)
                    return;
                dialogActive = true;
                root.addEventListener('click', onBlur);
                document.addEventListener('keydown', onEscape);
                iframe.focus();
                root.style.pointerEvents = 'auto';
                bodyStyle = Object.assign({}, document.body.style);
                document.body.style.overflow = 'hidden';
            };
            // dialog visibility
            let visible = false;
            const showDialog = () => {
                if (visible)
                    return;
                visible = true;
                if (document.activeElement instanceof HTMLElement)
                    opener = document.activeElement;
                root.removeAttribute('hidden');
                root.removeAttribute('aria-closed');
                root.showModal();
            };
            const hideDialog = () => {
                if (!visible)
                    return;
                visible = false;
                root.setAttribute('hidden', 'true');
                root.setAttribute('aria-closed', 'true');
                root.close();
                // 1password extension sometimes adds `inert` attribute to `dialog`
                // siblings and does not clean up remove when `dialog` closes
                // (after `<com-1password-notification />` closes)
                for (const sibling of root.parentNode
                    ? Array.from(root.parentNode.children)
                    : []) {
                    if (sibling === root)
                        continue;
                    if (!sibling.hasAttribute('inert'))
                        continue;
                    sibling.removeAttribute('inert');
                }
            };
            return {
                close() {
                    fallback.close();
                    open = false;
                    messenger.send('__internal', {
                        mode: 'iframe',
                        referrer: getReferrer(),
                        type: 'init',
                    });
                    hideDialog();
                    activatePage();
                },
                destroy() {
                    fallback.close();
                    open = false;
                    activatePage();
                    hideDialog();
                    fallback.destroy();
                    messenger.destroy();
                    root.remove();
                    inertObserver.disconnect();
                    drawerModeQuery.removeEventListener('change', onDrawerModeChange);
                },
                open() {
                    if (open)
                        return;
                    open = true;
                    showDialog();
                    activateDialog();
                    messenger.send('__internal', {
                        mode: 'iframe',
                        referrer: getReferrer(),
                        type: 'init',
                    });
                },
                async secure() {
                    const { trustedHosts } = await messenger.waitForReady();
                    const secureProtocol = (() => {
                        if (skipProtocolCheck)
                            return true;
                        const secure = window.location.protocol.startsWith('https');
                        if (!secure)
                            logger.warnOnce('Detected insecure protocol (HTTP).', `\n\nThe Porto iframe is not supported on HTTP origins (${window.location.origin})`, 'due to lack of WebAuthn support.', 'See https://porto.sh/sdk#secure-origins-https for more information.');
                        return secure;
                    })();
                    const intersectionObserverSupported = IO.supported();
                    const trustedHost = Boolean(trustedHosts?.includes(window.location.hostname));
                    const secureFrame = Boolean(intersectionObserverSupported || trustedHost);
                    if (!secureFrame)
                        logger.warnOnce([
                            `Warning: Browser does not support IntersectionObserver v2 or host "${hostUrl.hostname}" is not trusted by Porto.`,
                            'This may result in the dialog falling back to a popup.',
                            '',
                            `Add "${hostUrl.hostname}" to the trusted hosts list to enable iframe dialog: https://github.com/ithacaxyz/porto/edit/main/src/trusted-hosts.ts`,
                        ].join('\n'));
                    return {
                        frame: secureFrame,
                        host: trustedHost,
                        protocol: secureProtocol,
                    };
                },
                async syncRequests(requests) {
                    const { methodPolicies } = await messenger.waitForReady();
                    const secure = await this.secure();
                    const headless = requests?.every((request) => methodPolicies?.find((policy) => policy.method === request.request.method)?.modes?.headless === true);
                    const unsupported = includesUnsupported(requests.map((x) => x.request));
                    if (!headless && (unsupported || !secure.protocol || !secure.frame))
                        fallback.syncRequests(requests);
                    else {
                        const requiresConfirm = requests.some((x) => requiresConfirmation(x.request, {
                            methodPolicies,
                            targetOrigin: hostUrl.origin,
                        }));
                        if (!open && requiresConfirm)
                            this.open();
                        messenger.send('rpc-requests', requests);
                    }
                },
            };
        },
        supportsHeadless: true,
    });
}
/**
 * Instantiates a popup dialog.
 *
 * @returns Popup dialog.
 */
export function popup(options = {}) {
    if (typeof window === 'undefined')
        return noop();
    const { type = 'auto', size = defaultSize } = options;
    return from({
        name: 'popup',
        setup(parameters) {
            const { host, internal, themeController } = parameters;
            const { store } = internal;
            const hostUrl = new URL(host);
            let popup = null;
            const resolvedType = type === 'page' || (type === 'auto' && UserAgent.isMobile())
                ? 'page'
                : 'popup';
            function onBlur() {
                if (popup)
                    handleBlur(store);
            }
            const offDetectClosed = (() => {
                const timer = setInterval(() => {
                    if (popup?.closed)
                        handleBlur(store);
                }, 100);
                return () => clearInterval(timer);
            })();
            let messenger;
            themeController?._setup(null, true);
            return {
                close() {
                    if (!popup)
                        return;
                    popup.close();
                    popup = null;
                },
                destroy() {
                    this.close();
                    window.removeEventListener('focus', onBlur);
                    messenger?.destroy();
                    offDetectClosed();
                },
                open() {
                    if (resolvedType === 'popup') {
                        const left = (window.innerWidth - size.width) / 2 + window.screenX;
                        const top = window.screenY + 100;
                        popup = window.open(getDialogUrl(host), '_blank', `width=${size.width},height=${size.height},left=${left},top=${top}`);
                    }
                    else {
                        popup = window.open(getDialogUrl(host), '_blank');
                    }
                    if (!popup)
                        throw new Error('Failed to open popup');
                    messenger = Messenger.bridge({
                        from: Messenger.fromWindow(window, {
                            targetOrigin: hostUrl.origin,
                        }),
                        to: Messenger.fromWindow(popup, {
                            targetOrigin: hostUrl.origin,
                        }),
                        waitForReady: true,
                    });
                    themeController?._setup(messenger, false);
                    messenger.send('__internal', {
                        mode: resolvedType === 'page' ? 'page' : 'popup',
                        referrer: getReferrer(),
                        theme: themeController?.getTheme() ?? parameters.theme,
                        type: 'init',
                    });
                    messenger.on('rpc-response', (response) => handleResponse(store, response));
                    window.removeEventListener('focus', onBlur);
                    window.addEventListener('focus', onBlur);
                },
                async secure() {
                    return {
                        frame: true,
                        host: true,
                        protocol: true,
                    };
                },
                async syncRequests(requests) {
                    const requiresConfirm = requests.some((x) => requiresConfirmation(x.request));
                    if (requiresConfirm) {
                        if (!popup || popup.closed)
                            this.open();
                        popup?.focus();
                    }
                    messenger?.send('rpc-requests', requests);
                },
            };
        },
        supportsHeadless: false,
    });
}
/**
 * Instantiates a noop dialog.
 *
 * @returns Noop dialog.
 */
export function noop() {
    return from({
        name: 'noop',
        setup() {
            return {
                close() { },
                destroy() { },
                open() { },
                async secure() {
                    return {
                        frame: true,
                        host: true,
                        protocol: true,
                    };
                },
                async syncRequests() { },
            };
        },
        supportsHeadless: true,
    });
}
/**
 * Instantiates an inline iframe dialog rendered on a provided `element`.
 *
 * @param options - Options.
 * @returns Inline iframe dialog.
 */
export function experimental_inline(options) {
    const { element } = options;
    if (typeof window === 'undefined')
        return noop();
    return from({
        name: 'inline',
        setup(parameters) {
            const { host, internal, theme, themeController } = parameters;
            const { store } = internal;
            let open = false;
            const hostUrl = new URL(host);
            const root = document.createElement('div');
            root.dataset.porto = '';
            root.style.height = '100%';
            element().appendChild(root);
            const iframe = document.createElement('iframe');
            iframe.setAttribute('allow', `publickey-credentials-get ${hostUrl.origin}; publickey-credentials-create ${hostUrl.origin}`);
            iframe.setAttribute('aria-label', 'Porto Wallet');
            iframe.setAttribute('tabindex', '0');
            iframe.setAttribute('sandbox', 'allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox');
            iframe.setAttribute('src', getDialogUrl(host));
            iframe.setAttribute('title', 'Porto');
            Object.assign(iframe.style, {
                border: '0',
                height: '100%',
                width: '100%',
            });
            root.appendChild(iframe);
            const messenger = Messenger.bridge({
                from: Messenger.fromWindow(window, { targetOrigin: hostUrl.origin }),
                to: Messenger.fromWindow(iframe.contentWindow, {
                    targetOrigin: hostUrl.origin,
                }),
                waitForReady: true,
            });
            themeController?._setup(messenger, true);
            messenger.on('ready', () => {
                messenger.send('__internal', {
                    mode: 'inline-iframe',
                    referrer: getReferrer(),
                    theme,
                    type: 'init',
                });
            });
            messenger.on('rpc-response', (response) => handleResponse(store, response));
            return {
                close() { },
                destroy() {
                    messenger.destroy();
                    root.remove();
                },
                open() {
                    if (open)
                        return;
                    open = true;
                    messenger.send('__internal', {
                        mode: 'iframe',
                        referrer: getReferrer(),
                        type: 'init',
                    });
                },
                async secure() {
                    return {
                        frame: true,
                        host: true,
                        protocol: true,
                    };
                },
                async syncRequests(requests) {
                    messenger.send('rpc-requests', requests);
                },
            };
        },
        supportsHeadless: true,
    });
}
/**
 * A controller to update the dialog theme.
 */
export function createThemeController() {
    let lastTheme = null;
    let messenger = null;
    const controller = {
        _setup(messenger_, resetTheme = false) {
            if (resetTheme)
                lastTheme = null;
            messenger = messenger_;
        },
        getTheme() {
            return lastTheme;
        },
        setTheme(theme) {
            lastTheme = theme;
            messenger
                ?.send('__internal', {
                theme,
                type: 'set-theme',
            })
                .catch(() => { });
        },
    };
    return controller;
}
export const defaultSize = { height: 282, width: 360 };
export function requiresConfirmation(request, options = {}) {
    const { methodPolicies, targetOrigin } = options;
    const policy = methodPolicies?.find((x) => x.method === request.method);
    if (!policy)
        return true;
    if (policy.modes?.headless) {
        if (typeof policy.modes.headless === 'object' &&
            policy.modes.headless.sameOrigin &&
            targetOrigin !== window.location.origin)
            return true;
        return false;
    }
    return true;
}
export function getReferrer() {
    const icon = (() => {
        const dark = document.querySelector('link[rel="icon"][media="(prefers-color-scheme: dark)"]')?.href;
        const light = document.querySelector('link[rel="icon"][media="(prefers-color-scheme: light)"]')?.href ?? document.querySelector('link[rel="icon"]')?.href;
        if (dark && light && dark !== light)
            return { dark, light };
        const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (isDark)
            return dark;
        return light;
    })();
    return {
        icon,
        title: document.title,
    };
}
export function handleBlur(store) {
    store.setState((x) => ({
        ...x,
        requestQueue: x.requestQueue.map((x) => ({
            account: x.account,
            error: new Provider.UserRejectedRequestError(),
            request: x.request,
            status: 'error',
        })),
    }));
}
export function handleResponse(store, response) {
    store.setState((x) => ({
        ...x,
        requestQueue: x.requestQueue.map((queued) => {
            if (queued.request.id !== response.id)
                return queued;
            if (response.error)
                return {
                    account: queued.account,
                    error: response.error,
                    request: queued.request,
                    status: 'error',
                };
            return {
                account: queued.account,
                request: queued.request,
                result: response.result,
                status: 'success',
            };
        }),
    }));
}
export function getDialogUrl(host) {
    const url = new URL(host);
    const parentParams = new URLSearchParams(window.location.search);
    const prefix = 'porto.';
    for (const [key, value] of parentParams.entries()) {
        if (key.startsWith(prefix))
            url.searchParams.set(key.slice(prefix.length), value);
    }
    return url.toString();
}
//# sourceMappingURL=Dialog.js.map