<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XLayer NFT é“¸é€ ç«™ (é™æ€)</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
    <style>
        /* ä¿æŒä¹‹å‰çš„æ ·å¼ä¸å˜ï¼Œç¡®ä¿è§†è§‰å’Œå¸ƒå±€æ¸…æ™° */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f2f5; margin: 0; }
        .container { background: #fff; padding: 40px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); text-align: center; max-width: 450px; width: 90%; }
        h1 { color: #1e3a8a; margin-bottom: 25px; font-size: 1.8em; }
        button { background-color: #3b82f6; color: white; border: none; padding: 12px 24px; margin: 8px 0; border-radius: 8px; cursor: pointer; font-size: 16px; transition: background-color 0.3s, opacity 0.3s; width: 100%; font-weight: bold; }
        button:hover:not(:disabled) { background-color: #1d4ed8; }
        button:disabled { background-color: #9ca3af; cursor: not-allowed; opacity: 0.8; }
        .status { margin-top: 25px; padding: 15px; border-radius: 8px; font-size: 0.9em; text-align: left; line-height: 1.5; }
        .info { background-color: #e0f2fe; color: #075985; }
        .error { background-color: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
        .success { background-color: #d1fae5; color: #065f46; border: 1px solid #a7f3d0; }
        input[type="text"] { width: 95%; padding: 12px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 6px; box-sizing: border-box; font-size: 1em; }
        .data-display { text-align: left; margin-bottom: 20px; padding: 10px; background-color: #f9fafb; border-radius: 6px; }
        .data-display p { margin: 5px 0; font-size: 0.95em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>XLayer ODOG NFT é“¸é€ ç«™</h1>
        
        <button id="connectWalletBtn">è¿æ¥é’±åŒ…</button>
        
        <div id="mintArea" style="display: none;">
            <div class="data-display">
                <p>å½“å‰åœ°å€: <span id="currentAddress">--</span></p>
                <p>ODOG ä½™é¢: <span id="odogBalance">--</span></p>
                <p>æˆæƒé¢åº¦: <span id="allowanceStatus">--</span></p>
                <p>ç½‘ç»œ: <span id="currentNetwork" style="font-weight: bold;">æœªè¿æ¥</span></p>
            </div>

            <input type="text" id="messageInput" placeholder="è¯·è¾“å…¥ NFT æ¶ˆæ¯/å…ƒæ•°æ®">
            
            <button id="approveBtn" disabled>æˆæƒ 100 ODOG ç»™åˆçº¦</button>
            <button id="mintBtn" disabled>é“¸é€  NFT (100 ODOG)</button>
        </div>
        
        <div class="status info" id="statusMessage">è¯·è¿æ¥æ‚¨çš„ Web3 é’±åŒ… (ä¾‹å¦‚ MetaMask)ã€‚</div>
    </div>

    <script>
        // --- åˆçº¦å’ŒåŒºå—é“¾é…ç½® ---
        const XLAYER_CHAIN_ID = 196;
        const XLAYER_HEX_ID = '0xc4'; // 196 çš„åå…­è¿›åˆ¶è¡¨ç¤º
        const NFT_CONTRACT_ADDRESS = '0x8ed8ed9f316016fcE26722A84B214ADE7E3c7917';
        const ODOG_CONTRACT_ADDRESS = '0xc3f431cd1b7220cca703ee08c24ca645a71e72c8';
        const MINT_AMOUNT = ethers.utils.parseUnits('100', 18); 
        
        // XLayer ç½‘ç»œé…ç½®è¯¦æƒ… (ç”¨äºé’±åŒ…è‡ªåŠ¨åˆ‡æ¢)
        const XLAYER_NETWORK_DETAILS = {
            chainId: XLAYER_HEX_ID,
            chainName: 'XLayer Mainnet',
            nativeCurrency: { name: 'OKB', symbol: 'OKB', decimals: 18 },
            rpcUrls: ['https://rpc.xlayer.tech'],
            blockExplorerUrls: ['https://www.okx.com/explorer/xlayer/'],
        };
        
        // NFT å’Œ ODOG çš„ ABI (ä¿æŒä¸å˜)
        const NFT_ABI = [{"constant":false,"inputs":[{"internalType":"string","name":"message","type":"string"}],"name":"writeMessage","outputs":[],"stateMutability":"nonpayable","type":"function"}];
        const ODOG_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
        ];

        // --- Ethers å˜é‡å’Œ DOM å¼•ç”¨ (ä¿æŒä¸å˜) ---
        let provider, signer, userAddress, odogContract, nftContract;
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        const mintArea = document.getElementById('mintArea');
        const statusMessage = document.getElementById('statusMessage');
        const odogBalanceSpan = document.getElementById('odogBalance');
        const allowanceStatusSpan = document.getElementById('allowanceStatus');
        const approveBtn = document.getElementById('approveBtn');
        const mintBtn = document.getElementById('mintBtn');
        const currentNetworkSpan = document.getElementById('currentNetwork');
        const messageInput = document.getElementById('messageInput');
        const currentAddressSpan = document.getElementById('currentAddress');


        function updateStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status ${type}`;
        }
        
        function setButtonsState(approveDisabled, mintDisabled) {
            approveBtn.disabled = approveDisabled;
            mintBtn.disabled = mintDisabled;
        }
        
        /**
         * @dev å°è¯•æ·»åŠ æˆ–åˆ‡æ¢åˆ° XLayer ç½‘ç»œ
         */
        async function switchToXLayer() {
            if (!window.ethereum) return false;
            
            try {
                updateStatus('æ­£åœ¨è¯·æ±‚åˆ‡æ¢ç½‘ç»œåˆ° XLayer...', 'info');
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: XLAYER_HEX_ID }],
                });
                return true; // åˆ‡æ¢æˆåŠŸ
            } catch (switchError) {
                // å¦‚æœ XLayer ä¸åœ¨ç”¨æˆ·çš„ç½‘ç»œåˆ—è¡¨ä¸­ï¼Œåˆ™å°è¯•æ·»åŠ 
                if (switchError.code === 4902) {
                    try {
                        updateStatus('XLayer ä¸åœ¨æ‚¨çš„é’±åŒ…ä¸­ï¼Œæ­£åœ¨å°è¯•æ·»åŠ ç½‘ç»œ...', 'info');
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [XLAYER_NETWORK_DETAILS],
                        });
                        return true; // æ·»åŠ æˆåŠŸåï¼Œç”¨æˆ·éœ€è¦å†æ¬¡ç¡®è®¤åˆ‡æ¢
                    } catch (addError) {
                        updateStatus(`æ·»åŠ  XLayer å¤±è´¥: ${addError.message}`, 'error');
                        return false;
                    }
                }
                // ç”¨æˆ·æ‹’ç»åˆ‡æ¢
                updateStatus(`åˆ‡æ¢ç½‘ç»œå¤±è´¥: ${switchError.message}`, 'error');
                return false;
            }
        }

        /**
         * @dev è¿æ¥ Web3 é’±åŒ…
         */
        async function connectWallet() {
            // ç¡®ä¿é¡µé¢ä¸Šè‡³å°‘èƒ½æ˜¾ç¤º'æœªæ£€æµ‹åˆ°é’±åŒ…'çš„é”™è¯¯ï¼Œè€Œä¸æ˜¯æ²¡æœ‰ä»»ä½•ååº”
            if (typeof window.ethereum === 'undefined') {
                updateStatus('æœªæ£€æµ‹åˆ° Web3 é’±åŒ… (ä¾‹å¦‚ MetaMask)ã€‚è¯·å®‰è£…å¹¶åˆ·æ–°é¡µé¢ã€‚', 'error');
                return;
            }
            
            connectWalletBtn.disabled = true;

            try {
                // 1. è¯·æ±‚è¿æ¥é’±åŒ…ï¼ˆä¼šå¼¹å‡ºé’±åŒ…è¿æ¥æˆæƒçª—å£ï¼‰
                updateStatus('è¯·æ±‚è¿æ¥é’±åŒ…...', 'info');
                provider = new ethers.providers.Web3Provider(window.ethereum);
                // è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„ Web3 é’±åŒ…è¿æ¥æ–¹æ³•
                await provider.send("eth_requestAccounts", []);
                
                signer = provider.getSigner();
                userAddress = await signer.getAddress();

                // 2. æ£€æŸ¥å¹¶åˆ‡æ¢ç½‘ç»œ
                const { chainId } = await provider.getNetwork();
                
                if (chainId !== XLAYER_CHAIN_ID) {
                    const switched = await switchToXLayer();
                    if (!switched) {
                         // å¦‚æœåˆ‡æ¢å¤±è´¥ï¼Œåˆ™ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨åˆ‡æ¢
                        currentNetworkSpan.textContent = `âŒ é”™è¯¯ç½‘ç»œ (ID: ${chainId})`;
                        updateStatus('è¯·æ‰‹åŠ¨å°†æ‚¨çš„é’±åŒ…åˆ‡æ¢åˆ° XLayer åŒºå—é“¾ (ID 196)ã€‚', 'error');
                        connectWalletBtn.disabled = false;
                        mintArea.style.display = 'block';
                        setButtonsState(true, true);
                        return;
                    }
                    // é‡æ–°è·å–ç½‘ç»œä¿¡æ¯ (å› ä¸ºåˆ‡æ¢åï¼Œç”¨æˆ·å¯èƒ½éœ€è¦å†æ¬¡ç‚¹å‡» connect)
                    const newChainId = (await provider.getNetwork()).chainId;
                    if (newChainId !== XLAYER_CHAIN_ID) {
                        currentNetworkSpan.textContent = `âŒ ç­‰å¾…åˆ‡æ¢è‡³ XLayer`;
                        updateStatus('è¯·åœ¨é’±åŒ…ä¸­ç¡®è®¤åˆ‡æ¢åˆ° XLayerã€‚', 'error');
                        connectWalletBtn.disabled = false;
                        mintArea.style.display = 'block';
                        setButtonsState(true, true);
                        return;
                    }
                }

                // 3. è¿æ¥æˆåŠŸï¼Œåˆå§‹åŒ–åˆçº¦
                currentNetworkSpan.textContent = `âœ… XLayer (ID: ${XLAYER_CHAIN_ID})`;
                currentAddressSpan.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                updateStatus('é’±åŒ…è¿æ¥æˆåŠŸï¼æ­£åœ¨æ£€æŸ¥çŠ¶æ€...', 'info');
                
                odogContract = new ethers.Contract(ODOG_CONTRACT_ADDRESS, ODOG_ABI, signer);
                nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);

                connectWalletBtn.style.display = 'none';
                mintArea.style.display = 'block';

                await checkAndSetState();

            } catch (error) {
                console.error("è¿æ¥é’±åŒ…é”™è¯¯:", error);
                // å¸¸è§çš„é”™è¯¯ä»£ç  4001: ç”¨æˆ·æ‹’ç»è¿æ¥
                if (error.code === 4001) {
                    updateStatus('è¿æ¥è¢«ç”¨æˆ·æ‹’ç»ã€‚è¯·é‡è¯•ã€‚', 'error');
                } else {
                    updateStatus(`è¿æ¥å¤±è´¥: ${error.message || error}`, 'error');
                }
                connectWalletBtn.disabled = false;
            }
        }
        
        // ä¿æŒ checkAndSetState, approveODOG, mintNFT å‡½æ•°ä¸å˜...
        async function checkAndSetState() {
            try {
                setButtonsState(true, true); 
                const balance = await odogContract.balanceOf(userAddress);
                const odogBalanceFormatted = ethers.utils.formatUnits(balance, 18);
                odogBalanceSpan.textContent = odogBalanceFormatted;

                const hasEnoughBalance = balance.gte(MINT_AMOUNT);

                if (!hasEnoughBalance) {
                    odogBalanceSpan.style.color = 'red';
                    updateStatus(`æ‚¨çš„ ODOG ä½™é¢ (${odogBalanceFormatted}) ä¸è¶³ 100 ODOGã€‚`, 'error');
                    return;
                } else {
                    odogBalanceSpan.style.color = '#065f46';
                }

                const allowance = await odogContract.allowance(userAddress, NFT_CONTRACT_ADDRESS);
                const isApproved = allowance.gte(MINT_AMOUNT);
                const allowanceFormatted = ethers.utils.formatUnits(allowance, 18);

                allowanceStatusSpan.textContent = `${allowanceFormatted} ODOG`;

                if (isApproved) {
                    allowanceStatusSpan.style.color = '#065f46';
                    setButtonsState(true, false); 
                    updateStatus('âœ… ä½™é¢å……è¶³ï¼Œå·²æˆæƒï¼è¯·è®¾ç½®æ¶ˆæ¯å¹¶é“¸é€  NFTã€‚', 'success');
                } else {
                    allowanceStatusSpan.style.color = '#ca8a04'; 
                    setButtonsState(false, true); 
                    updateStatus('ä½™é¢å……è¶³ï¼Œä½†éœ€è¦å…ˆæˆæƒ NFT åˆçº¦èŠ±è´¹ 100 ODOGã€‚', 'info');
                }

            } catch (error) {
                console.error(error);
                updateStatus(`çŠ¶æ€æ£€æŸ¥å¤±è´¥: ${error.message || error}`, 'error');
            }
        }

        async function approveODOG() {
            setButtonsState(true, true);
            try {
                updateStatus('æ­£åœ¨è¯·æ±‚æˆæƒäº¤æ˜“... è¯·åœ¨é’±åŒ…ä¸­ç¡®è®¤ã€‚', 'info');
                const tx = await odogContract.approve(NFT_CONTRACT_ADDRESS, MINT_AMOUNT);
                updateStatus(`æˆæƒäº¤æ˜“å·²å‘é€ (${tx.hash.slice(0, 10)}...)ï¼Œè¯·ç­‰å¾…ç¡®è®¤...`, 'info');
                await tx.wait(); 
                updateStatus('âœ… ODOG æˆæƒæˆåŠŸï¼æ­£åœ¨æ›´æ–°çŠ¶æ€...', 'success');
                await checkAndSetState(); 
            } catch (error) {
                console.error(error);
                updateStatus(`æˆæƒå¤±è´¥: ${error.message || 'ç”¨æˆ·æ‹’ç»æˆ–äº¤æ˜“å¤±è´¥'}`, 'error');
                if (await odogContract.allowance(userAddress, NFT_CONTRACT_ADDRESS) < MINT_AMOUNT) {
                    setButtonsState(false, true); 
                }
            }
        }

        async function mintNFT() {
            const message = messageInput.value.trim();
            if (!message) {
                updateStatus('è¯·è¾“å…¥æ‚¨çš„ NFT æ¶ˆæ¯/å…ƒæ•°æ®ã€‚', 'error');
                return;
            }
            setButtonsState(true, true);
            
            try {
                updateStatus('æ­£åœ¨è¯·æ±‚é“¸é€ äº¤æ˜“... è¯·åœ¨é’±åŒ…ä¸­ç¡®è®¤ã€‚', 'info');
                const tx = await nftContract.writeMessage(message);
                updateStatus(`é“¸é€ äº¤æ˜“å·²å‘é€ (${tx.hash.slice(0, 10)}...)ï¼Œè¯·ç­‰å¾…ç¡®è®¤...`, 'info');
                await tx.wait();
                updateStatus(`ğŸ‰ NFT é“¸é€ æˆåŠŸ! äº¤æ˜“å“ˆå¸Œ: ${tx.hash.slice(0, 10)}...`, 'success');
                await checkAndSetState();
            } catch (error) {
                console.error(error);
                updateStatus(`é“¸é€ å¤±è´¥: ${error.message || 'ç”¨æˆ·æ‹’ç»æˆ–äº¤æ˜“å¤±è´¥'}`, 'error');
                await checkAndSetState();
            }
        }
        
        // --- äº‹ä»¶ç›‘å¬å™¨ (ä¿æŒä¸å˜) ---
        connectWalletBtn.addEventListener('click', connectWallet);
        approveBtn.addEventListener('click', approveODOG);
        mintBtn.addEventListener('click', mintNFT);

        if (window.ethereum) {
            window.ethereum.on('chainChanged', (chainId) => {
                window.location.reload(); 
            });
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    window.location.reload();
                } else {
                    connectWallet(); 
                }
            });
        }
    </script>
</body>
</html>
